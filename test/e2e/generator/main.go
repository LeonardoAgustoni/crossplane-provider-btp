package main

import (
	_ "embed"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/crossplane/crossplane-runtime/pkg/errors"
	ujconfig "github.com/crossplane/upjet/pkg/config"
	"github.com/muvaf/typewriter/pkg/wrapper"

	"github.com/sap/crossplane-provider-btp/config"
)

const tfResourcePrefix = "btp"

func main() {
	if len(os.Args) < 2 || os.Args[1] == "" {
		panic("root directory is required to be given as argument")
	}
	rootDir := os.Args[1]
	absRootDir, err := filepath.Abs(rootDir)
	if err != nil {
		panic(fmt.Sprintf("cannot calculate the absolute path with %s", rootDir))
	}

	// need to overide the rootgroup as we as want to control the name of the CRD groups
	provider := config.GetProvider()
	rg := provider.RootGroup
	fmt.Println(rg)

	run(provider, absRootDir)
}

func run(pc *ujconfig.Provider, rootDir string) {
	resourcesGroups := map[string]map[string]map[string]*ujconfig.Resource{}
	for name, resource := range pc.Resources {
		group := pc.RootGroup
		if resource.ShortGroup != "" {
			group = strings.ToLower(resource.ShortGroup) + "." + pc.RootGroup
		}
		if len(resourcesGroups[group]) == 0 {
			resourcesGroups[group] = map[string]map[string]*ujconfig.Resource{}
		}
		if len(resourcesGroups[group][resource.Version]) == 0 {
			resourcesGroups[group][resource.Version] = map[string]*ujconfig.Resource{}
		}
		resourcesGroups[group][resource.Version][name] = resource
	}
	for _, versions := range resourcesGroups {
		for _, resources := range versions {
			for _, name := range sortedResources(resources) {
				testgen := newTestGenerator(rootDir)
				_, err := testgen.generate(resources[name])
				if err != nil {
					panic(errors.Wrap(err, "cannot generate test files"))
				}
			}
		}
	}

}

func sortedResources(m map[string]*ujconfig.Resource) []string {
	result := make([]string, len(m))
	i := 0
	for g := range m {
		result[i] = g
		i++
	}
	sort.Strings(result)
	return result
}

//go:embed resource_test.go.tmpl
var template string

const (
	genStatement = "// Code initially generated by test-generator."
)

func newTestGenerator(rootDir string) *testGenerator {
	return &testGenerator{
		LocalDirectoryPath: filepath.Join(rootDir, "test", "e2e"),
		LicenseHeaderPath:  filepath.Join(rootDir, "hack", "boilerplate.go.txt"),
	}
}

type testGenerator struct {
	LocalDirectoryPath string
	LicenseHeaderPath  string
}

func (tg *testGenerator) generate(cfg *ujconfig.Resource) (string, error) {
	file := wrapper.NewFile("", "", template,
		wrapper.WithGenStatement(genStatement),
		wrapper.WithHeaderPath(tg.LicenseHeaderPath),
	)

	vars := map[string]any{
		"CRD": map[string]string{
			"APIVersion":   cfg.Version,
			"Kind":         cfg.Kind,
			"TypeLocation": typeLocation(cfg),
		},
	}

	filename := fmt.Sprintf("%s_%s_test.go", cfg.Name[len(tfResourcePrefix)+1:], strings.ToLower(cfg.Version))
	filePath := filepath.Join(tg.LocalDirectoryPath, filename)

	if err := createFolderIfNotExists(filepath.Join(tg.LocalDirectoryPath, "testdata", "crs", cfg.Kind)); err != nil {
		return filename, errors.Wrap(err, "cannot create folder")
	}

	if fileExists(filePath) {
		return filename, nil
	}

	return filename, errors.Wrap(file.Write(filePath, vars, os.ModePerm), "cannot write test file")
}

// TypeLocation for import path in test files
func typeLocation(cfg *ujconfig.Resource) string {
	subpath := ""
	if cfg.ShortGroup != "" {
		subpath = cfg.ShortGroup + "/"
	}
	return fmt.Sprintf("apis/%s%s", subpath, cfg.Version)
}

// Checks if a file/folder exists on the given path
func fileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

func createFolderIfNotExists(dir string) error {
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		if err := os.Mkdir(dir, os.ModePerm); err != nil {
			return errors.Wrap(err, "cannot create folder")
		}
	}

	return nil
}
