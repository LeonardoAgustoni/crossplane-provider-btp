/*
Accounts Service

The Accounts service provides REST APIs that are responsible for the management of global accounts, and the creation and management of directories, subaccounts, and their custom properties/tags.  Global accounts represent a business entity and contain contract information, including customer details and purchased entitlements. The global account is the context for billing each customer.  Use the subaccount APIs to structure your global account according to your organization's and project's requirements regarding members, authorizations, and quotas. This service also provides you with APIs for creating and managing directories. While the use of directories is optional, they allow you to further organize and manage your subaccounts according to your specific technical and business needs. The service also lets you manage the custom properties/tags that you associate with your directories and subaccounts. NOTE: These APIs are relevant only for cloud management tools feature set B. For details and information about whether this applies to your global account, see [Cloud Management Tools - Feature Set Overview](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/Cloud/en-US/caf4e4e23aef4666ad8f125af393dfb2.html).  See also: * [Authorization](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/3670474a58c24ac2b082e76cbbd9dc19.html) * [Rate Limiting](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/77b217b3f57a45b987eb7fbc3305ce1e.html) * [Error Response Format](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/77fef2fb104b4b1795e2e6cee790e8b8.html) * [Asynchronous Jobs](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/0a0a6ab0ad114d72a6611c1c6b21683e.html)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type DirectoryOperationsAPI interface {

	/*
	CreateDirectory Create a directory

	Directories allow you to organize and manage your subaccounts according to your technical and business needs.
A directory can contain one or more subaccounts and directories. The maximum number of directory levels allowed in a global account is 5.
Using directories to group subaccounts is optional.
If you have directories in your account model, you can still create subaccounts directly under your global account.

Required scope: $XSAPPNAME.global-account.account-directory.create

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateDirectoryRequest
	*/
	CreateDirectory(ctx context.Context) ApiCreateDirectoryRequest

	// CreateDirectoryExecute executes the request
	//  @return DirectoryResponseObject
	CreateDirectoryExecute(r ApiCreateDirectoryRequest) (*DirectoryResponseObject, *http.Response, error)

	/*
	CreateDirectoryLabels Assign labels to a directory

	Assign user-defined labels to a given directory. Labels are specified as key-value pairs.

Required scope: $XSAPPNAME.global-account.account-directory.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param directoryGUID The GUID of the directory.
	@return ApiCreateDirectoryLabelsRequest
	*/
	CreateDirectoryLabels(ctx context.Context, directoryGUID string) ApiCreateDirectoryLabelsRequest

	// CreateDirectoryLabelsExecute executes the request
	//  @return LabelsResponseObject
	CreateDirectoryLabelsExecute(r ApiCreateDirectoryLabelsRequest) (*LabelsResponseObject, *http.Response, error)

	/*
	CreateOrUpdateDirectorySettings Create or update directory settings

	Create or update directory settings for a specified directory.<br/><br/>Required scope: $XSAPPNAME.account-directory.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param directoryGUID The GUID of the directory.
	@return ApiCreateOrUpdateDirectorySettingsRequest
	*/
	CreateOrUpdateDirectorySettings(ctx context.Context, directoryGUID string) ApiCreateOrUpdateDirectorySettingsRequest

	// CreateOrUpdateDirectorySettingsExecute executes the request
	//  @return DataResponseObject
	CreateOrUpdateDirectorySettingsExecute(r ApiCreateOrUpdateDirectorySettingsRequest) (*DataResponseObject, *http.Response, error)

	/*
	DeleteDirectory Delete a directory

	Delete the directory, including its subdirectories, subaccounts, and their content.<br/><br/>Required scope: $XSAPPNAME.global-account.account-directory.delete

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param directoryGUID The GUID of the directory to delete.
	@return ApiDeleteDirectoryRequest
	*/
	DeleteDirectory(ctx context.Context, directoryGUID string) ApiDeleteDirectoryRequest

	// DeleteDirectoryExecute executes the request
	//  @return DirectoryResponseObject
	DeleteDirectoryExecute(r ApiDeleteDirectoryRequest) (*DirectoryResponseObject, *http.Response, error)

	/*
	DeleteDirectoryLabels Delete all labels from a directory

	Remove all user-defined labels that are assigned to a given directory.

To remove specific labels, use instead: PUT /accounts/v1/directories/{directoryGUID}/labels

Required scope: $XSAPPNAME.global-account.account-directory.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param directoryGUID The GUID of the directory
	@return ApiDeleteDirectoryLabelsRequest
	*/
	DeleteDirectoryLabels(ctx context.Context, directoryGUID string) ApiDeleteDirectoryLabelsRequest

	// DeleteDirectoryLabelsExecute executes the request
	//  @return LabelsResponseObject
	DeleteDirectoryLabelsExecute(r ApiDeleteDirectoryLabelsRequest) (*LabelsResponseObject, *http.Response, error)

	/*
	DeleteDirectorySettings Delete directory settings

	Delete directory settings for a specified directory.<br/><br/>Required scope: $XSAPPNAME.account-directory.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param directoryGUID The GUID of the directory.
	@return ApiDeleteDirectorySettingsRequest
	*/
	DeleteDirectorySettings(ctx context.Context, directoryGUID string) ApiDeleteDirectorySettingsRequest

	// DeleteDirectorySettingsExecute executes the request
	//  @return DataResponseObject
	DeleteDirectorySettingsExecute(r ApiDeleteDirectorySettingsRequest) (*DataResponseObject, *http.Response, error)

	/*
	GetDirectory Get a directory

	Get details for a specified directory.<br/><br/>Required scope: $XSAPPNAME.global-account.account-directory.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param directoryGUID The GUID of the directory for which to get details.
	@return ApiGetDirectoryRequest
	*/
	GetDirectory(ctx context.Context, directoryGUID string) ApiGetDirectoryRequest

	// GetDirectoryExecute executes the request
	//  @return DirectoryResponseObject
	GetDirectoryExecute(r ApiGetDirectoryRequest) (*DirectoryResponseObject, *http.Response, error)

	/*
	GetDirectoryCustomProperties Get custom properties for a directory (deprecated)

	Get all the custom properties that are assigned as key-value pairs to a given directory.

NOTE: This API is deprecated. Custom properties are now called labels. The "customProperties" field supports only single values per key and is now replaced by the string array "labels", which supports multiple values per key. This API returns only the first value of any label key that has multiple values assigned to it. Use instead: GET /accounts/v1/directories/{directoryGUID}/labels

Required scope: $XSAPPNAME.global-account.account-directory.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param directoryGUID The unique ID of the directory for which to get custom properties.
	@return ApiGetDirectoryCustomPropertiesRequest
	*/
	GetDirectoryCustomProperties(ctx context.Context, directoryGUID string) ApiGetDirectoryCustomPropertiesRequest

	// GetDirectoryCustomPropertiesExecute executes the request
	//  @return ResponseCollection
	GetDirectoryCustomPropertiesExecute(r ApiGetDirectoryCustomPropertiesRequest) (*ResponseCollection, *http.Response, error)

	/*
	GetDirectoryLabels Get labels for a directory

	Get all the user-defined labels, that are assigned as key-value pairs to a given directory. 

Required scope: $XSAPPNAME.global-account.account-directory.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param directoryGUID The GUID of the directory.
	@return ApiGetDirectoryLabelsRequest
	*/
	GetDirectoryLabels(ctx context.Context, directoryGUID string) ApiGetDirectoryLabelsRequest

	// GetDirectoryLabelsExecute executes the request
	//  @return LabelsResponseObject
	GetDirectoryLabelsExecute(r ApiGetDirectoryLabelsRequest) (*LabelsResponseObject, *http.Response, error)

	/*
	GetDirectorySettings Get directory settings

	Get directory settings for a specified directory.<br/><br/>Required scope: $XSAPPNAME.account-directory.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param directoryGUID The GUID of the directory.
	@return ApiGetDirectorySettingsRequest
	*/
	GetDirectorySettings(ctx context.Context, directoryGUID string) ApiGetDirectorySettingsRequest

	// GetDirectorySettingsExecute executes the request
	//  @return DataResponseObject
	GetDirectorySettingsExecute(r ApiGetDirectorySettingsRequest) (*DataResponseObject, *http.Response, error)

	/*
	UpdateDirectory Update a directory

	Update the properties of a directory.
You can update its display name, description, and assigned labels.<br/><br/>Required scope: $XSAPPNAME.account-directory.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param directoryGUID The GUID of the directory to update.
	@return ApiUpdateDirectoryRequest
	*/
	UpdateDirectory(ctx context.Context, directoryGUID string) ApiUpdateDirectoryRequest

	// UpdateDirectoryExecute executes the request
	//  @return DirectoryResponseObject
	UpdateDirectoryExecute(r ApiUpdateDirectoryRequest) (*DirectoryResponseObject, *http.Response, error)

	/*
	UpdateDirectoryFeatures Add or remove features for a directory

	Global account admins can enable additional features in a directory or remove features that are already enabled.

By default, all directories provide the following basic features: (1) group and filter subaccounts, (2) monitor usage and costs, and (3) set custom properties and tags. Optionally, you can allow a directory to also manage its own entitlements and its user authorizations.

All existing subaccounts and subdirectories in the directory implicitly inherit the capabilities of the enabled features in this directory.

NOTE: The user authorizations management feature must be applied in combination with the entitlement management feature. In other words, if the directory has both entitlement and user authorization management enable, you cannot disable just the entitlement management feature without also disabling user authorization management. Likewise, if a directory has only the default features enabled, you cannot enable user authorization management without also enabling entitlement management.

NOTE: Your multi-level account hierarchy can have more than one directory enabled with user authorization and/or entitlement management; however, only one directory in any directory path can have these features enabled. In other words, other directories above or below this directory in the same path can only have the default features specified. If you are not sure which features to enable, we recommend that you set only the default features, and then add features later on as they are needed.

Required scope: $XSAPPNAME.account-directory.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param directoryGUID The GUID of the directory to update directory features.
	@return ApiUpdateDirectoryFeaturesRequest
	*/
	UpdateDirectoryFeatures(ctx context.Context, directoryGUID string) ApiUpdateDirectoryFeaturesRequest

	// UpdateDirectoryFeaturesExecute executes the request
	//  @return DirectoryResponseObject
	UpdateDirectoryFeaturesExecute(r ApiUpdateDirectoryFeaturesRequest) (*DirectoryResponseObject, *http.Response, error)
}

// DirectoryOperationsAPIService DirectoryOperationsAPI service
type DirectoryOperationsAPIService service

type ApiCreateDirectoryRequest struct {
	ctx context.Context
	ApiService DirectoryOperationsAPI
	createDirectoryRequestPayload *CreateDirectoryRequestPayload
	parentGUID *string
}

func (r ApiCreateDirectoryRequest) CreateDirectoryRequestPayload(createDirectoryRequestPayload CreateDirectoryRequestPayload) ApiCreateDirectoryRequest {
	r.createDirectoryRequestPayload = &createDirectoryRequestPayload
	return r
}

// The unique ID of the directory&#39;s parent entity.  You can create the directory directly under a global account or another directory.
func (r ApiCreateDirectoryRequest) ParentGUID(parentGUID string) ApiCreateDirectoryRequest {
	r.parentGUID = &parentGUID
	return r
}

func (r ApiCreateDirectoryRequest) Execute() (*DirectoryResponseObject, *http.Response, error) {
	return r.ApiService.CreateDirectoryExecute(r)
}

/*
CreateDirectory Create a directory

Directories allow you to organize and manage your subaccounts according to your technical and business needs.
A directory can contain one or more subaccounts and directories. The maximum number of directory levels allowed in a global account is 5.
Using directories to group subaccounts is optional.
If you have directories in your account model, you can still create subaccounts directly under your global account.

Required scope: $XSAPPNAME.global-account.account-directory.create

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDirectoryRequest
*/
func (a *DirectoryOperationsAPIService) CreateDirectory(ctx context.Context) ApiCreateDirectoryRequest {
	return ApiCreateDirectoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DirectoryResponseObject
func (a *DirectoryOperationsAPIService) CreateDirectoryExecute(r ApiCreateDirectoryRequest) (*DirectoryResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DirectoryResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryOperationsAPIService.CreateDirectory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/directories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createDirectoryRequestPayload == nil {
		return localVarReturnValue, nil, reportError("createDirectoryRequestPayload is required and must be specified")
	}

	if r.parentGUID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentGUID", r.parentGUID, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDirectoryRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDirectoryLabelsRequest struct {
	ctx context.Context
	ApiService DirectoryOperationsAPI
	directoryGUID string
	labelAssignmentRequestPayload *LabelAssignmentRequestPayload
}

func (r ApiCreateDirectoryLabelsRequest) LabelAssignmentRequestPayload(labelAssignmentRequestPayload LabelAssignmentRequestPayload) ApiCreateDirectoryLabelsRequest {
	r.labelAssignmentRequestPayload = &labelAssignmentRequestPayload
	return r
}

func (r ApiCreateDirectoryLabelsRequest) Execute() (*LabelsResponseObject, *http.Response, error) {
	return r.ApiService.CreateDirectoryLabelsExecute(r)
}

/*
CreateDirectoryLabels Assign labels to a directory

Assign user-defined labels to a given directory. Labels are specified as key-value pairs.

Required scope: $XSAPPNAME.global-account.account-directory.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The GUID of the directory.
 @return ApiCreateDirectoryLabelsRequest
*/
func (a *DirectoryOperationsAPIService) CreateDirectoryLabels(ctx context.Context, directoryGUID string) ApiCreateDirectoryLabelsRequest {
	return ApiCreateDirectoryLabelsRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return LabelsResponseObject
func (a *DirectoryOperationsAPIService) CreateDirectoryLabelsExecute(r ApiCreateDirectoryLabelsRequest) (*LabelsResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LabelsResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryOperationsAPIService.CreateDirectoryLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/directories/{directoryGUID}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.labelAssignmentRequestPayload == nil {
		return localVarReturnValue, nil, reportError("labelAssignmentRequestPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.labelAssignmentRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrUpdateDirectorySettingsRequest struct {
	ctx context.Context
	ApiService DirectoryOperationsAPI
	directoryGUID string
	entitySettingsRequestPayload *EntitySettingsRequestPayload
}

func (r ApiCreateOrUpdateDirectorySettingsRequest) EntitySettingsRequestPayload(entitySettingsRequestPayload EntitySettingsRequestPayload) ApiCreateOrUpdateDirectorySettingsRequest {
	r.entitySettingsRequestPayload = &entitySettingsRequestPayload
	return r
}

func (r ApiCreateOrUpdateDirectorySettingsRequest) Execute() (*DataResponseObject, *http.Response, error) {
	return r.ApiService.CreateOrUpdateDirectorySettingsExecute(r)
}

/*
CreateOrUpdateDirectorySettings Create or update directory settings

Create or update directory settings for a specified directory.<br/><br/>Required scope: $XSAPPNAME.account-directory.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The GUID of the directory.
 @return ApiCreateOrUpdateDirectorySettingsRequest
*/
func (a *DirectoryOperationsAPIService) CreateOrUpdateDirectorySettings(ctx context.Context, directoryGUID string) ApiCreateOrUpdateDirectorySettingsRequest {
	return ApiCreateOrUpdateDirectorySettingsRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return DataResponseObject
func (a *DirectoryOperationsAPIService) CreateOrUpdateDirectorySettingsExecute(r ApiCreateOrUpdateDirectorySettingsRequest) (*DataResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryOperationsAPIService.CreateOrUpdateDirectorySettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/directories/{directoryGUID}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entitySettingsRequestPayload == nil {
		return localVarReturnValue, nil, reportError("entitySettingsRequestPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.entitySettingsRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDirectoryRequest struct {
	ctx context.Context
	ApiService DirectoryOperationsAPI
	directoryGUID string
	forceDelete *bool
}

// Specifies whether to delete the directory and all its content, including subdirectories, subaccounts, and data contained within (default is false). Content refers to any entity or data, such as applications, service instances, spaces, active subscriptions, brokers, platform, and members, depending on the type of subaccount (Neo or multi-environment).  When set to false, the request fails if the directory contains subdirectories and subaccounts, even if they are empty. When set to true, all content in the directory is permanently deleted. The deletion may take a while depending on the amount of content in your subaccounts.
func (r ApiDeleteDirectoryRequest) ForceDelete(forceDelete bool) ApiDeleteDirectoryRequest {
	r.forceDelete = &forceDelete
	return r
}

func (r ApiDeleteDirectoryRequest) Execute() (*DirectoryResponseObject, *http.Response, error) {
	return r.ApiService.DeleteDirectoryExecute(r)
}

/*
DeleteDirectory Delete a directory

Delete the directory, including its subdirectories, subaccounts, and their content.<br/><br/>Required scope: $XSAPPNAME.global-account.account-directory.delete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The GUID of the directory to delete.
 @return ApiDeleteDirectoryRequest
*/
func (a *DirectoryOperationsAPIService) DeleteDirectory(ctx context.Context, directoryGUID string) ApiDeleteDirectoryRequest {
	return ApiDeleteDirectoryRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return DirectoryResponseObject
func (a *DirectoryOperationsAPIService) DeleteDirectoryExecute(r ApiDeleteDirectoryRequest) (*DirectoryResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DirectoryResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryOperationsAPIService.DeleteDirectory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/directories/{directoryGUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceDelete", r.forceDelete, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDirectoryLabelsRequest struct {
	ctx context.Context
	ApiService DirectoryOperationsAPI
	directoryGUID string
}

func (r ApiDeleteDirectoryLabelsRequest) Execute() (*LabelsResponseObject, *http.Response, error) {
	return r.ApiService.DeleteDirectoryLabelsExecute(r)
}

/*
DeleteDirectoryLabels Delete all labels from a directory

Remove all user-defined labels that are assigned to a given directory.

To remove specific labels, use instead: PUT /accounts/v1/directories/{directoryGUID}/labels

Required scope: $XSAPPNAME.global-account.account-directory.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The GUID of the directory
 @return ApiDeleteDirectoryLabelsRequest
*/
func (a *DirectoryOperationsAPIService) DeleteDirectoryLabels(ctx context.Context, directoryGUID string) ApiDeleteDirectoryLabelsRequest {
	return ApiDeleteDirectoryLabelsRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return LabelsResponseObject
func (a *DirectoryOperationsAPIService) DeleteDirectoryLabelsExecute(r ApiDeleteDirectoryLabelsRequest) (*LabelsResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LabelsResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryOperationsAPIService.DeleteDirectoryLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/directories/{directoryGUID}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDirectorySettingsRequest struct {
	ctx context.Context
	ApiService DirectoryOperationsAPI
	directoryGUID string
	keys *[]string
}

// Keys for the property. Limited to 255 characters.
func (r ApiDeleteDirectorySettingsRequest) Keys(keys []string) ApiDeleteDirectorySettingsRequest {
	r.keys = &keys
	return r
}

func (r ApiDeleteDirectorySettingsRequest) Execute() (*DataResponseObject, *http.Response, error) {
	return r.ApiService.DeleteDirectorySettingsExecute(r)
}

/*
DeleteDirectorySettings Delete directory settings

Delete directory settings for a specified directory.<br/><br/>Required scope: $XSAPPNAME.account-directory.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The GUID of the directory.
 @return ApiDeleteDirectorySettingsRequest
*/
func (a *DirectoryOperationsAPIService) DeleteDirectorySettings(ctx context.Context, directoryGUID string) ApiDeleteDirectorySettingsRequest {
	return ApiDeleteDirectorySettingsRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return DataResponseObject
func (a *DirectoryOperationsAPIService) DeleteDirectorySettingsExecute(r ApiDeleteDirectorySettingsRequest) (*DataResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryOperationsAPIService.DeleteDirectorySettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/directories/{directoryGUID}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.keys == nil {
		return localVarReturnValue, nil, reportError("keys is required and must be specified")
	}

	{
		t := *r.keys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keys", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keys", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDirectoryRequest struct {
	ctx context.Context
	ApiService DirectoryOperationsAPI
	directoryGUID string
	expand *bool
}

// Whether to get the contents of the directory, for example the subaccounts it contains.
func (r ApiGetDirectoryRequest) Expand(expand bool) ApiGetDirectoryRequest {
	r.expand = &expand
	return r
}

func (r ApiGetDirectoryRequest) Execute() (*DirectoryResponseObject, *http.Response, error) {
	return r.ApiService.GetDirectoryExecute(r)
}

/*
GetDirectory Get a directory

Get details for a specified directory.<br/><br/>Required scope: $XSAPPNAME.global-account.account-directory.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The GUID of the directory for which to get details.
 @return ApiGetDirectoryRequest
*/
func (a *DirectoryOperationsAPIService) GetDirectory(ctx context.Context, directoryGUID string) ApiGetDirectoryRequest {
	return ApiGetDirectoryRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return DirectoryResponseObject
func (a *DirectoryOperationsAPIService) GetDirectoryExecute(r ApiGetDirectoryRequest) (*DirectoryResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DirectoryResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryOperationsAPIService.GetDirectory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/directories/{directoryGUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.expand != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expand", r.expand, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDirectoryCustomPropertiesRequest struct {
	ctx context.Context
	ApiService DirectoryOperationsAPI
	directoryGUID string
}

func (r ApiGetDirectoryCustomPropertiesRequest) Execute() (*ResponseCollection, *http.Response, error) {
	return r.ApiService.GetDirectoryCustomPropertiesExecute(r)
}

/*
GetDirectoryCustomProperties Get custom properties for a directory (deprecated)

Get all the custom properties that are assigned as key-value pairs to a given directory.

NOTE: This API is deprecated. Custom properties are now called labels. The "customProperties" field supports only single values per key and is now replaced by the string array "labels", which supports multiple values per key. This API returns only the first value of any label key that has multiple values assigned to it. Use instead: GET /accounts/v1/directories/{directoryGUID}/labels

Required scope: $XSAPPNAME.global-account.account-directory.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The unique ID of the directory for which to get custom properties.
 @return ApiGetDirectoryCustomPropertiesRequest
*/
func (a *DirectoryOperationsAPIService) GetDirectoryCustomProperties(ctx context.Context, directoryGUID string) ApiGetDirectoryCustomPropertiesRequest {
	return ApiGetDirectoryCustomPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return ResponseCollection
func (a *DirectoryOperationsAPIService) GetDirectoryCustomPropertiesExecute(r ApiGetDirectoryCustomPropertiesRequest) (*ResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryOperationsAPIService.GetDirectoryCustomProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/directories/{directoryGUID}/customProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDirectoryLabelsRequest struct {
	ctx context.Context
	ApiService DirectoryOperationsAPI
	directoryGUID string
}

func (r ApiGetDirectoryLabelsRequest) Execute() (*LabelsResponseObject, *http.Response, error) {
	return r.ApiService.GetDirectoryLabelsExecute(r)
}

/*
GetDirectoryLabels Get labels for a directory

Get all the user-defined labels, that are assigned as key-value pairs to a given directory. 

Required scope: $XSAPPNAME.global-account.account-directory.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The GUID of the directory.
 @return ApiGetDirectoryLabelsRequest
*/
func (a *DirectoryOperationsAPIService) GetDirectoryLabels(ctx context.Context, directoryGUID string) ApiGetDirectoryLabelsRequest {
	return ApiGetDirectoryLabelsRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return LabelsResponseObject
func (a *DirectoryOperationsAPIService) GetDirectoryLabelsExecute(r ApiGetDirectoryLabelsRequest) (*LabelsResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LabelsResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryOperationsAPIService.GetDirectoryLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/directories/{directoryGUID}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDirectorySettingsRequest struct {
	ctx context.Context
	ApiService DirectoryOperationsAPI
	directoryGUID string
	keys *[]string
}

// Keys for the property. Limited to 255 characters.
func (r ApiGetDirectorySettingsRequest) Keys(keys []string) ApiGetDirectorySettingsRequest {
	r.keys = &keys
	return r
}

func (r ApiGetDirectorySettingsRequest) Execute() (*DataResponseObject, *http.Response, error) {
	return r.ApiService.GetDirectorySettingsExecute(r)
}

/*
GetDirectorySettings Get directory settings

Get directory settings for a specified directory.<br/><br/>Required scope: $XSAPPNAME.account-directory.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The GUID of the directory.
 @return ApiGetDirectorySettingsRequest
*/
func (a *DirectoryOperationsAPIService) GetDirectorySettings(ctx context.Context, directoryGUID string) ApiGetDirectorySettingsRequest {
	return ApiGetDirectorySettingsRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return DataResponseObject
func (a *DirectoryOperationsAPIService) GetDirectorySettingsExecute(r ApiGetDirectorySettingsRequest) (*DataResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryOperationsAPIService.GetDirectorySettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/directories/{directoryGUID}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.keys != nil {
		t := *r.keys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keys", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keys", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDirectoryRequest struct {
	ctx context.Context
	ApiService DirectoryOperationsAPI
	directoryGUID string
	updateDirectoryRequestPayload *UpdateDirectoryRequestPayload
}

func (r ApiUpdateDirectoryRequest) UpdateDirectoryRequestPayload(updateDirectoryRequestPayload UpdateDirectoryRequestPayload) ApiUpdateDirectoryRequest {
	r.updateDirectoryRequestPayload = &updateDirectoryRequestPayload
	return r
}

func (r ApiUpdateDirectoryRequest) Execute() (*DirectoryResponseObject, *http.Response, error) {
	return r.ApiService.UpdateDirectoryExecute(r)
}

/*
UpdateDirectory Update a directory

Update the properties of a directory.
You can update its display name, description, and assigned labels.<br/><br/>Required scope: $XSAPPNAME.account-directory.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The GUID of the directory to update.
 @return ApiUpdateDirectoryRequest
*/
func (a *DirectoryOperationsAPIService) UpdateDirectory(ctx context.Context, directoryGUID string) ApiUpdateDirectoryRequest {
	return ApiUpdateDirectoryRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return DirectoryResponseObject
func (a *DirectoryOperationsAPIService) UpdateDirectoryExecute(r ApiUpdateDirectoryRequest) (*DirectoryResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DirectoryResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryOperationsAPIService.UpdateDirectory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/directories/{directoryGUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDirectoryRequestPayload == nil {
		return localVarReturnValue, nil, reportError("updateDirectoryRequestPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDirectoryRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDirectoryFeaturesRequest struct {
	ctx context.Context
	ApiService DirectoryOperationsAPI
	directoryGUID string
	updateDirectoryTypeRequestPayload *UpdateDirectoryTypeRequestPayload
}

func (r ApiUpdateDirectoryFeaturesRequest) UpdateDirectoryTypeRequestPayload(updateDirectoryTypeRequestPayload UpdateDirectoryTypeRequestPayload) ApiUpdateDirectoryFeaturesRequest {
	r.updateDirectoryTypeRequestPayload = &updateDirectoryTypeRequestPayload
	return r
}

func (r ApiUpdateDirectoryFeaturesRequest) Execute() (*DirectoryResponseObject, *http.Response, error) {
	return r.ApiService.UpdateDirectoryFeaturesExecute(r)
}

/*
UpdateDirectoryFeatures Add or remove features for a directory

Global account admins can enable additional features in a directory or remove features that are already enabled.

By default, all directories provide the following basic features: (1) group and filter subaccounts, (2) monitor usage and costs, and (3) set custom properties and tags. Optionally, you can allow a directory to also manage its own entitlements and its user authorizations.

All existing subaccounts and subdirectories in the directory implicitly inherit the capabilities of the enabled features in this directory.

NOTE: The user authorizations management feature must be applied in combination with the entitlement management feature. In other words, if the directory has both entitlement and user authorization management enable, you cannot disable just the entitlement management feature without also disabling user authorization management. Likewise, if a directory has only the default features enabled, you cannot enable user authorization management without also enabling entitlement management.

NOTE: Your multi-level account hierarchy can have more than one directory enabled with user authorization and/or entitlement management; however, only one directory in any directory path can have these features enabled. In other words, other directories above or below this directory in the same path can only have the default features specified. If you are not sure which features to enable, we recommend that you set only the default features, and then add features later on as they are needed.

Required scope: $XSAPPNAME.account-directory.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The GUID of the directory to update directory features.
 @return ApiUpdateDirectoryFeaturesRequest
*/
func (a *DirectoryOperationsAPIService) UpdateDirectoryFeatures(ctx context.Context, directoryGUID string) ApiUpdateDirectoryFeaturesRequest {
	return ApiUpdateDirectoryFeaturesRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return DirectoryResponseObject
func (a *DirectoryOperationsAPIService) UpdateDirectoryFeaturesExecute(r ApiUpdateDirectoryFeaturesRequest) (*DirectoryResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DirectoryResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DirectoryOperationsAPIService.UpdateDirectoryFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/directories/{directoryGUID}/changeDirectoryFeatures"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDirectoryTypeRequestPayload == nil {
		return localVarReturnValue, nil, reportError("updateDirectoryTypeRequestPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDirectoryTypeRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
