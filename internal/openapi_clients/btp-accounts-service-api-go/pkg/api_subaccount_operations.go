/*
Accounts Service

The Accounts service provides REST APIs that are responsible for the management of global accounts, and the creation and management of directories, subaccounts, and their custom properties/tags.  Global accounts represent a business entity and contain contract information, including customer details and purchased entitlements. The global account is the context for billing each customer.  Use the subaccount APIs to structure your global account according to your organization's and project's requirements regarding members, authorizations, and quotas. This service also provides you with APIs for creating and managing directories. While the use of directories is optional, they allow you to further organize and manage your subaccounts according to your specific technical and business needs. The service also lets you manage the custom properties/tags that you associate with your directories and subaccounts. NOTE: These APIs are relevant only for cloud management tools feature set B. For details and information about whether this applies to your global account, see [Cloud Management Tools - Feature Set Overview](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/Cloud/en-US/caf4e4e23aef4666ad8f125af393dfb2.html).  See also: * [Authorization](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/3670474a58c24ac2b082e76cbbd9dc19.html) * [Rate Limiting](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/77b217b3f57a45b987eb7fbc3305ce1e.html) * [Error Response Format](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/77fef2fb104b4b1795e2e6cee790e8b8.html) * [Asynchronous Jobs](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/0a0a6ab0ad114d72a6611c1c6b21683e.html)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type SubaccountOperationsAPI interface {

	/*
	CloneNeoSubaccount Clone a Neo subaccount

	Create a clone of an existing Neo-based subaccount in a given global account.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.create

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sourceSubaccountGUID The GUID of the Neo subaccount to clone.
	@return ApiCloneNeoSubaccountRequest
	*/
	CloneNeoSubaccount(ctx context.Context, sourceSubaccountGUID string) ApiCloneNeoSubaccountRequest

	// CloneNeoSubaccountExecute executes the request
	//  @return SubaccountResponseObject
	CloneNeoSubaccountExecute(r ApiCloneNeoSubaccountRequest) (*SubaccountResponseObject, *http.Response, error)

	/*
	CreateOrUpdateSubaccountSettings Create or update subaccount settings

	Create or update subaccount settings for a specified subaccount.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount.
	@return ApiCreateOrUpdateSubaccountSettingsRequest
	*/
	CreateOrUpdateSubaccountSettings(ctx context.Context, subaccountGUID string) ApiCreateOrUpdateSubaccountSettingsRequest

	// CreateOrUpdateSubaccountSettingsExecute executes the request
	//  @return DataResponseObject
	CreateOrUpdateSubaccountSettingsExecute(r ApiCreateOrUpdateSubaccountSettingsRequest) (*DataResponseObject, *http.Response, error)

	/*
	CreateServiceManagementBinding Create a Service Manager binding

	Use this API to create a service instance and binding for a specified subaccount to get credentials to access Service Manager APIs.<br><br> We create this instance and binding for you directly in your subaccount, and as such, they are not associated with or restricted to any specific environment.<br> The instance and binding created with this API have generic names:<br> - ServiceManagementAccessInstance<br> - ServiceManagementAccessBinding

  **Tip**
 To view the created instance and binding, use the GET /accounts/v1/subaccounts/{subaccountGUID}/serviceManagementBinding API.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount for which to create a binding to access Service Manager.
	@return ApiCreateServiceManagementBindingRequest
	*/
	CreateServiceManagementBinding(ctx context.Context, subaccountGUID string) ApiCreateServiceManagementBindingRequest

	// CreateServiceManagementBindingExecute executes the request
	//  @return ServiceManagerBindingResponseObject
	CreateServiceManagementBindingExecute(r ApiCreateServiceManagementBindingRequest) (*ServiceManagerBindingResponseObject, *http.Response, error)

	/*
	CreateServiceManagerBindingV2 Create a Service Manager binding

	Use this API to create a service instance and associated bindings for a specified subaccount to get credentials to access Service Manager APIs.<br><br> We create this instance and bindings for you directly in your subaccount, and as such, they are not associated with or restricted to any specific environment.<br> The instance created with this API has a generic name:<br> - ServiceManagementAccessInstance<br><br> You can create more than one binding associated with the created service instance.<br> This has many benefits, for example if you need to use credentials rotation.<br><br>There are two types of service bindings you can create, depending on the credentials type:<br> - Binding with Basic credentials<br> - Binding with mTLS credentials<br><br> The binding with Basic credentials is a default type that you get without specifying any parameters in the *CreateServiceManagerBindingRequestPayload* object. If you wish to use the mTLS type, specify parameters.<br> For example: {
 "credential-type": "x509",
 "x509": {
 "key-length": 2048,
 "validity": 7,
 "validity-type": "DAYS"
 }

  **Tip**
 To view the created instance and bindings, use the *GET /accounts/accounts/v2/subaccounts/{subaccountGUID}/serviceManagerBindings/{bindingName}* API.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount for which to create a binding to access Service Manager.
	@return ApiCreateServiceManagerBindingV2Request
	*/
	CreateServiceManagerBindingV2(ctx context.Context, subaccountGUID string) ApiCreateServiceManagerBindingV2Request

	// CreateServiceManagerBindingV2Execute executes the request
	//  @return ServiceManagerBindingExtendedResponseObject
	CreateServiceManagerBindingV2Execute(r ApiCreateServiceManagerBindingV2Request) (*ServiceManagerBindingExtendedResponseObject, *http.Response, error)

	/*
	CreateSubaccount Create a subaccount

	Create a subaccount in a global account or directory.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.create

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateSubaccountRequest
	*/
	CreateSubaccount(ctx context.Context) ApiCreateSubaccountRequest

	// CreateSubaccountExecute executes the request
	//  @return SubaccountResponseObject
	CreateSubaccountExecute(r ApiCreateSubaccountRequest) (*SubaccountResponseObject, *http.Response, error)

	/*
	CreateSubaccountLabels Assign labels to a subaccount

	Assign user-defined labels to a given subaccount. Labels are specified as key-value pairs. 

Required scope: $XSAPPNAME.global-account.subaccount.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID Unique ID of the subaccount.
	@return ApiCreateSubaccountLabelsRequest
	*/
	CreateSubaccountLabels(ctx context.Context, subaccountGUID string) ApiCreateSubaccountLabelsRequest

	// CreateSubaccountLabelsExecute executes the request
	//  @return LabelsResponseObject
	CreateSubaccountLabelsExecute(r ApiCreateSubaccountLabelsRequest) (*LabelsResponseObject, *http.Response, error)

	/*
	DeleteServiceManagementBindingOfSubaccount Delete a Service Manager binding

	Delete an existing Service Manager instance and binding that were created as the result of the *POST/accounts/v1/subaccounts/{subaccountGUID}/serviceManagementBinding* API call for a specified subaccount to access and work with the Service Management APIs.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount for which to delete this instance and binding.
	@return ApiDeleteServiceManagementBindingOfSubaccountRequest
	*/
	DeleteServiceManagementBindingOfSubaccount(ctx context.Context, subaccountGUID string) ApiDeleteServiceManagementBindingOfSubaccountRequest

	// DeleteServiceManagementBindingOfSubaccountExecute executes the request
	DeleteServiceManagementBindingOfSubaccountExecute(r ApiDeleteServiceManagementBindingOfSubaccountRequest) (*http.Response, error)

	/*
	DeleteServiceManagerBindingV2 Delete a Service Manager binding

	Delete an existing Service Manager binding. <br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount for which to delete this binding.
	@param bindingName The name of the binding to delete.
	@return ApiDeleteServiceManagerBindingV2Request
	*/
	DeleteServiceManagerBindingV2(ctx context.Context, subaccountGUID string, bindingName string) ApiDeleteServiceManagerBindingV2Request

	// DeleteServiceManagerBindingV2Execute executes the request
	DeleteServiceManagerBindingV2Execute(r ApiDeleteServiceManagerBindingV2Request) (*http.Response, error)

	/*
	DeleteSubaccount Delete a subaccount 

	Delete the subaccount and its content.</br><br/>Required scope: $XSAPPNAME.global-account.subaccount.delete

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount for which to get details.
	@return ApiDeleteSubaccountRequest
	*/
	DeleteSubaccount(ctx context.Context, subaccountGUID string) ApiDeleteSubaccountRequest

	// DeleteSubaccountExecute executes the request
	//  @return SubaccountResponseObject
	DeleteSubaccountExecute(r ApiDeleteSubaccountRequest) (*SubaccountResponseObject, *http.Response, error)

	/*
	DeleteSubaccountLabels Remove all labels from a subaccount

	Remove all user-defined labels that are assigned to a given subaccount.

To remove specific labels, use instead: PUT /accounts/v1/subaccounts/{subaccountGUID}/labels

Required scope: $XSAPPNAME.global-account.subaccount.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount.
	@return ApiDeleteSubaccountLabelsRequest
	*/
	DeleteSubaccountLabels(ctx context.Context, subaccountGUID string) ApiDeleteSubaccountLabelsRequest

	// DeleteSubaccountLabelsExecute executes the request
	//  @return LabelsResponseObject
	DeleteSubaccountLabelsExecute(r ApiDeleteSubaccountLabelsRequest) (*LabelsResponseObject, *http.Response, error)

	/*
	DeleteSubaccountSettings Delete subaccount settings

	Delete subaccount settings for a specified subaccount.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount.
	@return ApiDeleteSubaccountSettingsRequest
	*/
	DeleteSubaccountSettings(ctx context.Context, subaccountGUID string) ApiDeleteSubaccountSettingsRequest

	// DeleteSubaccountSettingsExecute executes the request
	//  @return DataResponseObject
	DeleteSubaccountSettingsExecute(r ApiDeleteSubaccountSettingsRequest) (*DataResponseObject, *http.Response, error)

	/*
	GetAllServiceManagerBindingsV2 Get all Service Manager bindings

	View all Service Manager bindings.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount for which to get the bindings.
	@return ApiGetAllServiceManagerBindingsV2Request
	*/
	GetAllServiceManagerBindingsV2(ctx context.Context, subaccountGUID string) ApiGetAllServiceManagerBindingsV2Request

	// GetAllServiceManagerBindingsV2Execute executes the request
	//  @return ServiceManagerBindingsResponseList
	GetAllServiceManagerBindingsV2Execute(r ApiGetAllServiceManagerBindingsV2Request) (*ServiceManagerBindingsResponseList, *http.Response, error)

	/*
	GetServiceManagementBinding Get a Service Manager binding

	View the details of an existing Service Manager binding that was created as the result of the *POST /accounts/v1/subaccounts/{subaccountGUID}/serviceManagementBinding* API call for a specified subaccount to access and work with the Service Management APIs.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount for which to get the binding.
	@return ApiGetServiceManagementBindingRequest
	*/
	GetServiceManagementBinding(ctx context.Context, subaccountGUID string) ApiGetServiceManagementBindingRequest

	// GetServiceManagementBindingExecute executes the request
	//  @return ServiceManagerBindingResponseObject
	GetServiceManagementBindingExecute(r ApiGetServiceManagementBindingRequest) (*ServiceManagerBindingResponseObject, *http.Response, error)

	/*
	GetServiceManagerBindingV2 Get a Service Manager binding

	View the details of an existing Service Manager binding.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount for which to get the binding.
	@param bindingName The name of the binding for which to get details.
	@return ApiGetServiceManagerBindingV2Request
	*/
	GetServiceManagerBindingV2(ctx context.Context, subaccountGUID string, bindingName string) ApiGetServiceManagerBindingV2Request

	// GetServiceManagerBindingV2Execute executes the request
	//  @return ServiceManagerBindingExtendedResponseObject
	GetServiceManagerBindingV2Execute(r ApiGetServiceManagerBindingV2Request) (*ServiceManagerBindingExtendedResponseObject, *http.Response, error)

	/*
	GetSubaccount Get a subaccount

	Get information for a specified subaccount.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount
	@return ApiGetSubaccountRequest
	*/
	GetSubaccount(ctx context.Context, subaccountGUID string) ApiGetSubaccountRequest

	// GetSubaccountExecute executes the request
	//  @return SubaccountResponseObject
	GetSubaccountExecute(r ApiGetSubaccountRequest) (*SubaccountResponseObject, *http.Response, error)

	/*
	GetSubaccountCustomProperties Get custom properties for a subaccount (deprecated)

	 Get all the user-defined custom properties that are assigned as key-value pairs to a given subaccount.

NOTE: This API is deprecated. Custom properties are now called labels. The "customProperties" field supports only single values per key and is now replaced by the string array "labels", which supports multiple values per key. This API returns only the first value of any label key that has multiple values assigned to it. Use instead: GET /accounts/v1/subaccounts/{subaccountGUID}/labels
 Required scope: $XSAPPNAME.global-account.subaccount.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID Unique ID of the subaccount.
	@return ApiGetSubaccountCustomPropertiesRequest
	*/
	GetSubaccountCustomProperties(ctx context.Context, subaccountGUID string) ApiGetSubaccountCustomPropertiesRequest

	// GetSubaccountCustomPropertiesExecute executes the request
	//  @return ResponseCollection
	GetSubaccountCustomPropertiesExecute(r ApiGetSubaccountCustomPropertiesRequest) (*ResponseCollection, *http.Response, error)

	/*
	GetSubaccountLabels Get labels for a subaccount

	Get all the user-defined labels that are assigned as key-value pairs to a given subaccount. 

Required scope: $XSAPPNAME.global-account.subaccount.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount.
	@return ApiGetSubaccountLabelsRequest
	*/
	GetSubaccountLabels(ctx context.Context, subaccountGUID string) ApiGetSubaccountLabelsRequest

	// GetSubaccountLabelsExecute executes the request
	//  @return LabelsResponseObject
	GetSubaccountLabelsExecute(r ApiGetSubaccountLabelsRequest) (*LabelsResponseObject, *http.Response, error)

	/*
	GetSubaccountSettings Get subaccount settings

	Get subaccount settings for a specified subaccount.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount.
	@return ApiGetSubaccountSettingsRequest
	*/
	GetSubaccountSettings(ctx context.Context, subaccountGUID string) ApiGetSubaccountSettingsRequest

	// GetSubaccountSettingsExecute executes the request
	//  @return DataResponseObject
	GetSubaccountSettingsExecute(r ApiGetSubaccountSettingsRequest) (*DataResponseObject, *http.Response, error)

	/*
	GetSubaccounts Get all subaccounts

	Get information for all subaccounts in the global account and those under directories, if they exist.<br/><br/>Required scopes:
* When derivedAuthorizations is empty, then $XSAPPNAME.global-account.subaccount.read
* When derivedAuthorizations=any, then requires any valid token from XSUAA.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSubaccountsRequest
	*/
	GetSubaccounts(ctx context.Context) ApiGetSubaccountsRequest

	// GetSubaccountsExecute executes the request
	//  @return ResponseCollection
	GetSubaccountsExecute(r ApiGetSubaccountsRequest) (*ResponseCollection, *http.Response, error)

	/*
	MoveSubaccount Move a subaccount

	Move a subaccount to a different directory or out of a directory to the global account.<br/><br/>Required scopes for source directory:
$XSAPPNAME.global-account.subaccount.read,
$XSAPPNAME.global-account.subaccount.delete.


Required scopes for target directory:
$XSAPPNAME.global-account.subaccount.create

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The unique ID of the subaccount to move.
	@return ApiMoveSubaccountRequest
	*/
	MoveSubaccount(ctx context.Context, subaccountGUID string) ApiMoveSubaccountRequest

	// MoveSubaccountExecute executes the request
	//  @return SubaccountResponseObject
	MoveSubaccountExecute(r ApiMoveSubaccountRequest) (*SubaccountResponseObject, *http.Response, error)

	/*
	MoveSubaccounts Batch move subaccounts

	Move several subaccounts at once to a different directory or out of a directory to the global account.<br/><br/>Required scopes for source directory:
$XSAPPNAME.global-account.subaccount.read,
$XSAPPNAME.global-account.subaccount.delete.


Required scopes for target directory:
$XSAPPNAME.global-account.subaccount.create

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMoveSubaccountsRequest
	*/
	MoveSubaccounts(ctx context.Context) ApiMoveSubaccountsRequest

	// MoveSubaccountsExecute executes the request
	//  @return ResponseCollection
	MoveSubaccountsExecute(r ApiMoveSubaccountsRequest) (*ResponseCollection, *http.Response, error)

	/*
	UpdateSubaccount Update a subaccount

	Update a subaccount in the global account.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subaccountGUID The GUID of the subaccount to update.
	@return ApiUpdateSubaccountRequest
	*/
	UpdateSubaccount(ctx context.Context, subaccountGUID string) ApiUpdateSubaccountRequest

	// UpdateSubaccountExecute executes the request
	//  @return SubaccountResponseObject
	UpdateSubaccountExecute(r ApiUpdateSubaccountRequest) (*SubaccountResponseObject, *http.Response, error)
}

// SubaccountOperationsAPIService SubaccountOperationsAPI service
type SubaccountOperationsAPIService service

type ApiCloneNeoSubaccountRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	sourceSubaccountGUID string
	cloneNeoSubaccountRequestPayload *CloneNeoSubaccountRequestPayload
	subaccountAdmin *string
}

func (r ApiCloneNeoSubaccountRequest) CloneNeoSubaccountRequestPayload(cloneNeoSubaccountRequestPayload CloneNeoSubaccountRequestPayload) ApiCloneNeoSubaccountRequest {
	r.cloneNeoSubaccountRequestPayload = &cloneNeoSubaccountRequestPayload
	return r
}

// To prevent errors, special characters must be URL encoded. For example, the e-mail \&quot;name+dev_user@example.com\&quot; must be encoded as: name%2Bdev_user@example.com. You can add users only from the same user base as you (example: sap.default or custom identity provider).
func (r ApiCloneNeoSubaccountRequest) SubaccountAdmin(subaccountAdmin string) ApiCloneNeoSubaccountRequest {
	r.subaccountAdmin = &subaccountAdmin
	return r
}

func (r ApiCloneNeoSubaccountRequest) Execute() (*SubaccountResponseObject, *http.Response, error) {
	return r.ApiService.CloneNeoSubaccountExecute(r)
}

/*
CloneNeoSubaccount Clone a Neo subaccount

Create a clone of an existing Neo-based subaccount in a given global account.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.create

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceSubaccountGUID The GUID of the Neo subaccount to clone.
 @return ApiCloneNeoSubaccountRequest
*/
func (a *SubaccountOperationsAPIService) CloneNeoSubaccount(ctx context.Context, sourceSubaccountGUID string) ApiCloneNeoSubaccountRequest {
	return ApiCloneNeoSubaccountRequest{
		ApiService: a,
		ctx: ctx,
		sourceSubaccountGUID: sourceSubaccountGUID,
	}
}

// Execute executes the request
//  @return SubaccountResponseObject
func (a *SubaccountOperationsAPIService) CloneNeoSubaccountExecute(r ApiCloneNeoSubaccountRequest) (*SubaccountResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.CloneNeoSubaccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/clone/{sourceSubaccountGUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceSubaccountGUID"+"}", url.PathEscape(parameterValueToString(r.sourceSubaccountGUID, "sourceSubaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cloneNeoSubaccountRequestPayload == nil {
		return localVarReturnValue, nil, reportError("cloneNeoSubaccountRequestPayload is required and must be specified")
	}

	if r.subaccountAdmin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subaccountAdmin", r.subaccountAdmin, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloneNeoSubaccountRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrUpdateSubaccountSettingsRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
	entitySettingsRequestPayload *EntitySettingsRequestPayload
}

func (r ApiCreateOrUpdateSubaccountSettingsRequest) EntitySettingsRequestPayload(entitySettingsRequestPayload EntitySettingsRequestPayload) ApiCreateOrUpdateSubaccountSettingsRequest {
	r.entitySettingsRequestPayload = &entitySettingsRequestPayload
	return r
}

func (r ApiCreateOrUpdateSubaccountSettingsRequest) Execute() (*DataResponseObject, *http.Response, error) {
	return r.ApiService.CreateOrUpdateSubaccountSettingsExecute(r)
}

/*
CreateOrUpdateSubaccountSettings Create or update subaccount settings

Create or update subaccount settings for a specified subaccount.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount.
 @return ApiCreateOrUpdateSubaccountSettingsRequest
*/
func (a *SubaccountOperationsAPIService) CreateOrUpdateSubaccountSettings(ctx context.Context, subaccountGUID string) ApiCreateOrUpdateSubaccountSettingsRequest {
	return ApiCreateOrUpdateSubaccountSettingsRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return DataResponseObject
func (a *SubaccountOperationsAPIService) CreateOrUpdateSubaccountSettingsExecute(r ApiCreateOrUpdateSubaccountSettingsRequest) (*DataResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.CreateOrUpdateSubaccountSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entitySettingsRequestPayload == nil {
		return localVarReturnValue, nil, reportError("entitySettingsRequestPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.entitySettingsRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateServiceManagementBindingRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
}

func (r ApiCreateServiceManagementBindingRequest) Execute() (*ServiceManagerBindingResponseObject, *http.Response, error) {
	return r.ApiService.CreateServiceManagementBindingExecute(r)
}

/*
CreateServiceManagementBinding Create a Service Manager binding

Use this API to create a service instance and binding for a specified subaccount to get credentials to access Service Manager APIs.<br><br> We create this instance and binding for you directly in your subaccount, and as such, they are not associated with or restricted to any specific environment.<br> The instance and binding created with this API have generic names:<br> - ServiceManagementAccessInstance<br> - ServiceManagementAccessBinding

  **Tip**
 To view the created instance and binding, use the GET /accounts/v1/subaccounts/{subaccountGUID}/serviceManagementBinding API.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount for which to create a binding to access Service Manager.
 @return ApiCreateServiceManagementBindingRequest
*/
func (a *SubaccountOperationsAPIService) CreateServiceManagementBinding(ctx context.Context, subaccountGUID string) ApiCreateServiceManagementBindingRequest {
	return ApiCreateServiceManagementBindingRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return ServiceManagerBindingResponseObject
func (a *SubaccountOperationsAPIService) CreateServiceManagementBindingExecute(r ApiCreateServiceManagementBindingRequest) (*ServiceManagerBindingResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceManagerBindingResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.CreateServiceManagementBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}/serviceManagementBinding"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateServiceManagerBindingV2Request struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
	createServiceManagerBindingRequestPayload *CreateServiceManagerBindingRequestPayload
}

func (r ApiCreateServiceManagerBindingV2Request) CreateServiceManagerBindingRequestPayload(createServiceManagerBindingRequestPayload CreateServiceManagerBindingRequestPayload) ApiCreateServiceManagerBindingV2Request {
	r.createServiceManagerBindingRequestPayload = &createServiceManagerBindingRequestPayload
	return r
}

func (r ApiCreateServiceManagerBindingV2Request) Execute() (*ServiceManagerBindingExtendedResponseObject, *http.Response, error) {
	return r.ApiService.CreateServiceManagerBindingV2Execute(r)
}

/*
CreateServiceManagerBindingV2 Create a Service Manager binding

Use this API to create a service instance and associated bindings for a specified subaccount to get credentials to access Service Manager APIs.<br><br> We create this instance and bindings for you directly in your subaccount, and as such, they are not associated with or restricted to any specific environment.<br> The instance created with this API has a generic name:<br> - ServiceManagementAccessInstance<br><br> You can create more than one binding associated with the created service instance.<br> This has many benefits, for example if you need to use credentials rotation.<br><br>There are two types of service bindings you can create, depending on the credentials type:<br> - Binding with Basic credentials<br> - Binding with mTLS credentials<br><br> The binding with Basic credentials is a default type that you get without specifying any parameters in the *CreateServiceManagerBindingRequestPayload* object. If you wish to use the mTLS type, specify parameters.<br> For example: {
 "credential-type": "x509",
 "x509": {
 "key-length": 2048,
 "validity": 7,
 "validity-type": "DAYS"
 }

  **Tip**
 To view the created instance and bindings, use the *GET /accounts/accounts/v2/subaccounts/{subaccountGUID}/serviceManagerBindings/{bindingName}* API.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount for which to create a binding to access Service Manager.
 @return ApiCreateServiceManagerBindingV2Request
*/
func (a *SubaccountOperationsAPIService) CreateServiceManagerBindingV2(ctx context.Context, subaccountGUID string) ApiCreateServiceManagerBindingV2Request {
	return ApiCreateServiceManagerBindingV2Request{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return ServiceManagerBindingExtendedResponseObject
func (a *SubaccountOperationsAPIService) CreateServiceManagerBindingV2Execute(r ApiCreateServiceManagerBindingV2Request) (*ServiceManagerBindingExtendedResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceManagerBindingExtendedResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.CreateServiceManagerBindingV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v2/subaccounts/{subaccountGUID}/serviceManagerBindings"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createServiceManagerBindingRequestPayload == nil {
		return localVarReturnValue, nil, reportError("createServiceManagerBindingRequestPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createServiceManagerBindingRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubaccountRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	createSubaccountRequestPayload *CreateSubaccountRequestPayload
	subaccountAdmin *string
}

func (r ApiCreateSubaccountRequest) CreateSubaccountRequestPayload(createSubaccountRequestPayload CreateSubaccountRequestPayload) ApiCreateSubaccountRequest {
	r.createSubaccountRequestPayload = &createSubaccountRequestPayload
	return r
}

// To prevent errors, special characters must be URL encoded. For example, the e-mail \&quot;name+dev_user@example.com\&quot; must be encoded as: name%2Bdev_user@example.com. You can add users only from the same user base as you (example: sap.default or custom identity provider).
func (r ApiCreateSubaccountRequest) SubaccountAdmin(subaccountAdmin string) ApiCreateSubaccountRequest {
	r.subaccountAdmin = &subaccountAdmin
	return r
}

func (r ApiCreateSubaccountRequest) Execute() (*SubaccountResponseObject, *http.Response, error) {
	return r.ApiService.CreateSubaccountExecute(r)
}

/*
CreateSubaccount Create a subaccount

Create a subaccount in a global account or directory.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.create

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSubaccountRequest
*/
func (a *SubaccountOperationsAPIService) CreateSubaccount(ctx context.Context) ApiCreateSubaccountRequest {
	return ApiCreateSubaccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubaccountResponseObject
func (a *SubaccountOperationsAPIService) CreateSubaccountExecute(r ApiCreateSubaccountRequest) (*SubaccountResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.CreateSubaccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSubaccountRequestPayload == nil {
		return localVarReturnValue, nil, reportError("createSubaccountRequestPayload is required and must be specified")
	}

	if r.subaccountAdmin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subaccountAdmin", r.subaccountAdmin, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSubaccountRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubaccountLabelsRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
	labelAssignmentRequestPayload *LabelAssignmentRequestPayload
}

func (r ApiCreateSubaccountLabelsRequest) LabelAssignmentRequestPayload(labelAssignmentRequestPayload LabelAssignmentRequestPayload) ApiCreateSubaccountLabelsRequest {
	r.labelAssignmentRequestPayload = &labelAssignmentRequestPayload
	return r
}

func (r ApiCreateSubaccountLabelsRequest) Execute() (*LabelsResponseObject, *http.Response, error) {
	return r.ApiService.CreateSubaccountLabelsExecute(r)
}

/*
CreateSubaccountLabels Assign labels to a subaccount

Assign user-defined labels to a given subaccount. Labels are specified as key-value pairs. 

Required scope: $XSAPPNAME.global-account.subaccount.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID Unique ID of the subaccount.
 @return ApiCreateSubaccountLabelsRequest
*/
func (a *SubaccountOperationsAPIService) CreateSubaccountLabels(ctx context.Context, subaccountGUID string) ApiCreateSubaccountLabelsRequest {
	return ApiCreateSubaccountLabelsRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return LabelsResponseObject
func (a *SubaccountOperationsAPIService) CreateSubaccountLabelsExecute(r ApiCreateSubaccountLabelsRequest) (*LabelsResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LabelsResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.CreateSubaccountLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.labelAssignmentRequestPayload == nil {
		return localVarReturnValue, nil, reportError("labelAssignmentRequestPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.labelAssignmentRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteServiceManagementBindingOfSubaccountRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
}

func (r ApiDeleteServiceManagementBindingOfSubaccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteServiceManagementBindingOfSubaccountExecute(r)
}

/*
DeleteServiceManagementBindingOfSubaccount Delete a Service Manager binding

Delete an existing Service Manager instance and binding that were created as the result of the *POST/accounts/v1/subaccounts/{subaccountGUID}/serviceManagementBinding* API call for a specified subaccount to access and work with the Service Management APIs.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount for which to delete this instance and binding.
 @return ApiDeleteServiceManagementBindingOfSubaccountRequest
*/
func (a *SubaccountOperationsAPIService) DeleteServiceManagementBindingOfSubaccount(ctx context.Context, subaccountGUID string) ApiDeleteServiceManagementBindingOfSubaccountRequest {
	return ApiDeleteServiceManagementBindingOfSubaccountRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
func (a *SubaccountOperationsAPIService) DeleteServiceManagementBindingOfSubaccountExecute(r ApiDeleteServiceManagementBindingOfSubaccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.DeleteServiceManagementBindingOfSubaccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}/serviceManagementBinding"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteServiceManagerBindingV2Request struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
	bindingName string
}

func (r ApiDeleteServiceManagerBindingV2Request) Execute() (*http.Response, error) {
	return r.ApiService.DeleteServiceManagerBindingV2Execute(r)
}

/*
DeleteServiceManagerBindingV2 Delete a Service Manager binding

Delete an existing Service Manager binding. <br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount for which to delete this binding.
 @param bindingName The name of the binding to delete.
 @return ApiDeleteServiceManagerBindingV2Request
*/
func (a *SubaccountOperationsAPIService) DeleteServiceManagerBindingV2(ctx context.Context, subaccountGUID string, bindingName string) ApiDeleteServiceManagerBindingV2Request {
	return ApiDeleteServiceManagerBindingV2Request{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
		bindingName: bindingName,
	}
}

// Execute executes the request
func (a *SubaccountOperationsAPIService) DeleteServiceManagerBindingV2Execute(r ApiDeleteServiceManagerBindingV2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.DeleteServiceManagerBindingV2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v2/subaccounts/{subaccountGUID}/serviceManagerBindings/{bindingName}"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bindingName"+"}", url.PathEscape(parameterValueToString(r.bindingName, "bindingName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSubaccountRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
	forceDelete *bool
}

// Specifies whether to delete the subaccount if it contains content (default is false). Content refers to any entity or data, such as applications, service instances, spaces, active subscriptions, brokers, platform, and members, depending on the type of subaccount (Neo or multi-environment). When set to false, the request fails if the subaccount is not empty. When set to true, all content in the subaccount is permanently deleted. Depending on the amount of content in the subaccount, it may take several hours for the subaccount to be deleted. After the subaccount is deleted, it may take a few more days for some related services to be deleted. You won&#39;t be charged for any continued usage of these services in the subaccount during the deletion cleanup.
func (r ApiDeleteSubaccountRequest) ForceDelete(forceDelete bool) ApiDeleteSubaccountRequest {
	r.forceDelete = &forceDelete
	return r
}

func (r ApiDeleteSubaccountRequest) Execute() (*SubaccountResponseObject, *http.Response, error) {
	return r.ApiService.DeleteSubaccountExecute(r)
}

/*
DeleteSubaccount Delete a subaccount 

Delete the subaccount and its content.</br><br/>Required scope: $XSAPPNAME.global-account.subaccount.delete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount for which to get details.
 @return ApiDeleteSubaccountRequest
*/
func (a *SubaccountOperationsAPIService) DeleteSubaccount(ctx context.Context, subaccountGUID string) ApiDeleteSubaccountRequest {
	return ApiDeleteSubaccountRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return SubaccountResponseObject
func (a *SubaccountOperationsAPIService) DeleteSubaccountExecute(r ApiDeleteSubaccountRequest) (*SubaccountResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.DeleteSubaccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceDelete", r.forceDelete, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSubaccountLabelsRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
}

func (r ApiDeleteSubaccountLabelsRequest) Execute() (*LabelsResponseObject, *http.Response, error) {
	return r.ApiService.DeleteSubaccountLabelsExecute(r)
}

/*
DeleteSubaccountLabels Remove all labels from a subaccount

Remove all user-defined labels that are assigned to a given subaccount.

To remove specific labels, use instead: PUT /accounts/v1/subaccounts/{subaccountGUID}/labels

Required scope: $XSAPPNAME.global-account.subaccount.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount.
 @return ApiDeleteSubaccountLabelsRequest
*/
func (a *SubaccountOperationsAPIService) DeleteSubaccountLabels(ctx context.Context, subaccountGUID string) ApiDeleteSubaccountLabelsRequest {
	return ApiDeleteSubaccountLabelsRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return LabelsResponseObject
func (a *SubaccountOperationsAPIService) DeleteSubaccountLabelsExecute(r ApiDeleteSubaccountLabelsRequest) (*LabelsResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LabelsResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.DeleteSubaccountLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSubaccountSettingsRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
	keys *[]string
}

// Keys for the property. Limited to 255 characters.
func (r ApiDeleteSubaccountSettingsRequest) Keys(keys []string) ApiDeleteSubaccountSettingsRequest {
	r.keys = &keys
	return r
}

func (r ApiDeleteSubaccountSettingsRequest) Execute() (*DataResponseObject, *http.Response, error) {
	return r.ApiService.DeleteSubaccountSettingsExecute(r)
}

/*
DeleteSubaccountSettings Delete subaccount settings

Delete subaccount settings for a specified subaccount.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount.
 @return ApiDeleteSubaccountSettingsRequest
*/
func (a *SubaccountOperationsAPIService) DeleteSubaccountSettings(ctx context.Context, subaccountGUID string) ApiDeleteSubaccountSettingsRequest {
	return ApiDeleteSubaccountSettingsRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return DataResponseObject
func (a *SubaccountOperationsAPIService) DeleteSubaccountSettingsExecute(r ApiDeleteSubaccountSettingsRequest) (*DataResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.DeleteSubaccountSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.keys == nil {
		return localVarReturnValue, nil, reportError("keys is required and must be specified")
	}

	{
		t := *r.keys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keys", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keys", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllServiceManagerBindingsV2Request struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
}

func (r ApiGetAllServiceManagerBindingsV2Request) Execute() (*ServiceManagerBindingsResponseList, *http.Response, error) {
	return r.ApiService.GetAllServiceManagerBindingsV2Execute(r)
}

/*
GetAllServiceManagerBindingsV2 Get all Service Manager bindings

View all Service Manager bindings.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount for which to get the bindings.
 @return ApiGetAllServiceManagerBindingsV2Request
*/
func (a *SubaccountOperationsAPIService) GetAllServiceManagerBindingsV2(ctx context.Context, subaccountGUID string) ApiGetAllServiceManagerBindingsV2Request {
	return ApiGetAllServiceManagerBindingsV2Request{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return ServiceManagerBindingsResponseList
func (a *SubaccountOperationsAPIService) GetAllServiceManagerBindingsV2Execute(r ApiGetAllServiceManagerBindingsV2Request) (*ServiceManagerBindingsResponseList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceManagerBindingsResponseList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.GetAllServiceManagerBindingsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v2/subaccounts/{subaccountGUID}/serviceManagerBindings"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceManagementBindingRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
}

func (r ApiGetServiceManagementBindingRequest) Execute() (*ServiceManagerBindingResponseObject, *http.Response, error) {
	return r.ApiService.GetServiceManagementBindingExecute(r)
}

/*
GetServiceManagementBinding Get a Service Manager binding

View the details of an existing Service Manager binding that was created as the result of the *POST /accounts/v1/subaccounts/{subaccountGUID}/serviceManagementBinding* API call for a specified subaccount to access and work with the Service Management APIs.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount for which to get the binding.
 @return ApiGetServiceManagementBindingRequest
*/
func (a *SubaccountOperationsAPIService) GetServiceManagementBinding(ctx context.Context, subaccountGUID string) ApiGetServiceManagementBindingRequest {
	return ApiGetServiceManagementBindingRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return ServiceManagerBindingResponseObject
func (a *SubaccountOperationsAPIService) GetServiceManagementBindingExecute(r ApiGetServiceManagementBindingRequest) (*ServiceManagerBindingResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceManagerBindingResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.GetServiceManagementBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}/serviceManagementBinding"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceManagerBindingV2Request struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
	bindingName string
}

func (r ApiGetServiceManagerBindingV2Request) Execute() (*ServiceManagerBindingExtendedResponseObject, *http.Response, error) {
	return r.ApiService.GetServiceManagerBindingV2Execute(r)
}

/*
GetServiceManagerBindingV2 Get a Service Manager binding

View the details of an existing Service Manager binding.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount for which to get the binding.
 @param bindingName The name of the binding for which to get details.
 @return ApiGetServiceManagerBindingV2Request
*/
func (a *SubaccountOperationsAPIService) GetServiceManagerBindingV2(ctx context.Context, subaccountGUID string, bindingName string) ApiGetServiceManagerBindingV2Request {
	return ApiGetServiceManagerBindingV2Request{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
		bindingName: bindingName,
	}
}

// Execute executes the request
//  @return ServiceManagerBindingExtendedResponseObject
func (a *SubaccountOperationsAPIService) GetServiceManagerBindingV2Execute(r ApiGetServiceManagerBindingV2Request) (*ServiceManagerBindingExtendedResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceManagerBindingExtendedResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.GetServiceManagerBindingV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v2/subaccounts/{subaccountGUID}/serviceManagerBindings/{bindingName}"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bindingName"+"}", url.PathEscape(parameterValueToString(r.bindingName, "bindingName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubaccountRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
	derivedAuthorizations *string
}

// The range of authorizations for which to return information. * any: Returns all global accounts for which the user has authorizations on any of the accounts&#39; entities, such as its subaccounts (for example, user is a subaccount admin) or spaces (for example, user is a Cloud Foundry space manager). * (empty value): Returns all subaccounts for which the user has explicit authorization ($XSAPPNAME.global-account.subaccount.read) on the global account or directory.
func (r ApiGetSubaccountRequest) DerivedAuthorizations(derivedAuthorizations string) ApiGetSubaccountRequest {
	r.derivedAuthorizations = &derivedAuthorizations
	return r
}

func (r ApiGetSubaccountRequest) Execute() (*SubaccountResponseObject, *http.Response, error) {
	return r.ApiService.GetSubaccountExecute(r)
}

/*
GetSubaccount Get a subaccount

Get information for a specified subaccount.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount
 @return ApiGetSubaccountRequest
*/
func (a *SubaccountOperationsAPIService) GetSubaccount(ctx context.Context, subaccountGUID string) ApiGetSubaccountRequest {
	return ApiGetSubaccountRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return SubaccountResponseObject
func (a *SubaccountOperationsAPIService) GetSubaccountExecute(r ApiGetSubaccountRequest) (*SubaccountResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.GetSubaccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.derivedAuthorizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "derivedAuthorizations", r.derivedAuthorizations, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubaccountCustomPropertiesRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
}

func (r ApiGetSubaccountCustomPropertiesRequest) Execute() (*ResponseCollection, *http.Response, error) {
	return r.ApiService.GetSubaccountCustomPropertiesExecute(r)
}

/*
GetSubaccountCustomProperties Get custom properties for a subaccount (deprecated)

 Get all the user-defined custom properties that are assigned as key-value pairs to a given subaccount.

NOTE: This API is deprecated. Custom properties are now called labels. The "customProperties" field supports only single values per key and is now replaced by the string array "labels", which supports multiple values per key. This API returns only the first value of any label key that has multiple values assigned to it. Use instead: GET /accounts/v1/subaccounts/{subaccountGUID}/labels
 Required scope: $XSAPPNAME.global-account.subaccount.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID Unique ID of the subaccount.
 @return ApiGetSubaccountCustomPropertiesRequest
*/
func (a *SubaccountOperationsAPIService) GetSubaccountCustomProperties(ctx context.Context, subaccountGUID string) ApiGetSubaccountCustomPropertiesRequest {
	return ApiGetSubaccountCustomPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return ResponseCollection
func (a *SubaccountOperationsAPIService) GetSubaccountCustomPropertiesExecute(r ApiGetSubaccountCustomPropertiesRequest) (*ResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.GetSubaccountCustomProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}/customProperties"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubaccountLabelsRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
}

func (r ApiGetSubaccountLabelsRequest) Execute() (*LabelsResponseObject, *http.Response, error) {
	return r.ApiService.GetSubaccountLabelsExecute(r)
}

/*
GetSubaccountLabels Get labels for a subaccount

Get all the user-defined labels that are assigned as key-value pairs to a given subaccount. 

Required scope: $XSAPPNAME.global-account.subaccount.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount.
 @return ApiGetSubaccountLabelsRequest
*/
func (a *SubaccountOperationsAPIService) GetSubaccountLabels(ctx context.Context, subaccountGUID string) ApiGetSubaccountLabelsRequest {
	return ApiGetSubaccountLabelsRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return LabelsResponseObject
func (a *SubaccountOperationsAPIService) GetSubaccountLabelsExecute(r ApiGetSubaccountLabelsRequest) (*LabelsResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LabelsResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.GetSubaccountLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubaccountSettingsRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
	keys *[]string
}

// Keys for the property. Limited to 255 characters.
func (r ApiGetSubaccountSettingsRequest) Keys(keys []string) ApiGetSubaccountSettingsRequest {
	r.keys = &keys
	return r
}

func (r ApiGetSubaccountSettingsRequest) Execute() (*DataResponseObject, *http.Response, error) {
	return r.ApiService.GetSubaccountSettingsExecute(r)
}

/*
GetSubaccountSettings Get subaccount settings

Get subaccount settings for a specified subaccount.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount.
 @return ApiGetSubaccountSettingsRequest
*/
func (a *SubaccountOperationsAPIService) GetSubaccountSettings(ctx context.Context, subaccountGUID string) ApiGetSubaccountSettingsRequest {
	return ApiGetSubaccountSettingsRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return DataResponseObject
func (a *SubaccountOperationsAPIService) GetSubaccountSettingsExecute(r ApiGetSubaccountSettingsRequest) (*DataResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.GetSubaccountSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.keys != nil {
		t := *r.keys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keys", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keys", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubaccountsRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	directoryGUID *string
	derivedAuthorizations *string
	labelSelector *string
}

// Returns only the subaccounts in a given directory. Provide the unique ID of the directory.
func (r ApiGetSubaccountsRequest) DirectoryGUID(directoryGUID string) ApiGetSubaccountsRequest {
	r.directoryGUID = &directoryGUID
	return r
}

// The range of authorizations for which to return information. * any: Returns all global accounts for which the user has authorizations on any of the accounts&#39; entities, such as its subaccounts (for example, user is a subaccount admin) or spaces (for example, user is a Cloud Foundry space manager). * (empty value): Returns all subaccounts for which the user has explicit authorization ($XSAPPNAME.global-account.subaccount.read) on the global account or directory.
func (r ApiGetSubaccountsRequest) DerivedAuthorizations(derivedAuthorizations string) ApiGetSubaccountsRequest {
	r.derivedAuthorizations = &derivedAuthorizations
	return r
}

// Get all existing subaccounts that match or don&#39;t match one or more user-defined labels. Specify the key-value pair of the label using either the equals (&#x3D;) or not equals operator (!&#x3D;). Keys, values, and operator must be URL encoded. Use the AND operand to include more than one label in the query. You can specify only a single value per key. Parameter does not support label keys or values that include space, &#x3D;, or ! characters. Usage example where the keys \&quot;my-key-1\&quot; and \&quot;my-key-2\&quot; have the values \&quot;my-value-1\&quot; and \&quot;my-value-2\&quot; , respectively: my-key-1%3Dmy-value-1%20AND%20my-key-2%3Dmy-value-2
func (r ApiGetSubaccountsRequest) LabelSelector(labelSelector string) ApiGetSubaccountsRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiGetSubaccountsRequest) Execute() (*ResponseCollection, *http.Response, error) {
	return r.ApiService.GetSubaccountsExecute(r)
}

/*
GetSubaccounts Get all subaccounts

Get information for all subaccounts in the global account and those under directories, if they exist.<br/><br/>Required scopes:
* When derivedAuthorizations is empty, then $XSAPPNAME.global-account.subaccount.read
* When derivedAuthorizations=any, then requires any valid token from XSUAA.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubaccountsRequest
*/
func (a *SubaccountOperationsAPIService) GetSubaccounts(ctx context.Context) ApiGetSubaccountsRequest {
	return ApiGetSubaccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResponseCollection
func (a *SubaccountOperationsAPIService) GetSubaccountsExecute(r ApiGetSubaccountsRequest) (*ResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.GetSubaccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.directoryGUID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryGUID", r.directoryGUID, "form", "")
	}
	if r.derivedAuthorizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "derivedAuthorizations", r.derivedAuthorizations, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labelSelector", r.labelSelector, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoveSubaccountRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
	moveSubaccountRequestPayload *MoveSubaccountRequestPayload
}

func (r ApiMoveSubaccountRequest) MoveSubaccountRequestPayload(moveSubaccountRequestPayload MoveSubaccountRequestPayload) ApiMoveSubaccountRequest {
	r.moveSubaccountRequestPayload = &moveSubaccountRequestPayload
	return r
}

func (r ApiMoveSubaccountRequest) Execute() (*SubaccountResponseObject, *http.Response, error) {
	return r.ApiService.MoveSubaccountExecute(r)
}

/*
MoveSubaccount Move a subaccount

Move a subaccount to a different directory or out of a directory to the global account.<br/><br/>Required scopes for source directory:
$XSAPPNAME.global-account.subaccount.read,
$XSAPPNAME.global-account.subaccount.delete.


Required scopes for target directory:
$XSAPPNAME.global-account.subaccount.create

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The unique ID of the subaccount to move.
 @return ApiMoveSubaccountRequest
*/
func (a *SubaccountOperationsAPIService) MoveSubaccount(ctx context.Context, subaccountGUID string) ApiMoveSubaccountRequest {
	return ApiMoveSubaccountRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return SubaccountResponseObject
func (a *SubaccountOperationsAPIService) MoveSubaccountExecute(r ApiMoveSubaccountRequest) (*SubaccountResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.MoveSubaccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}/move"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveSubaccountRequestPayload == nil {
		return localVarReturnValue, nil, reportError("moveSubaccountRequestPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveSubaccountRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoveSubaccountsRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	moveSubaccountsRequestPayloadCollection *MoveSubaccountsRequestPayloadCollection
}

func (r ApiMoveSubaccountsRequest) MoveSubaccountsRequestPayloadCollection(moveSubaccountsRequestPayloadCollection MoveSubaccountsRequestPayloadCollection) ApiMoveSubaccountsRequest {
	r.moveSubaccountsRequestPayloadCollection = &moveSubaccountsRequestPayloadCollection
	return r
}

func (r ApiMoveSubaccountsRequest) Execute() (*ResponseCollection, *http.Response, error) {
	return r.ApiService.MoveSubaccountsExecute(r)
}

/*
MoveSubaccounts Batch move subaccounts

Move several subaccounts at once to a different directory or out of a directory to the global account.<br/><br/>Required scopes for source directory:
$XSAPPNAME.global-account.subaccount.read,
$XSAPPNAME.global-account.subaccount.delete.


Required scopes for target directory:
$XSAPPNAME.global-account.subaccount.create

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMoveSubaccountsRequest
*/
func (a *SubaccountOperationsAPIService) MoveSubaccounts(ctx context.Context) ApiMoveSubaccountsRequest {
	return ApiMoveSubaccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResponseCollection
func (a *SubaccountOperationsAPIService) MoveSubaccountsExecute(r ApiMoveSubaccountsRequest) (*ResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.MoveSubaccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/move"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.moveSubaccountsRequestPayloadCollection == nil {
		return localVarReturnValue, nil, reportError("moveSubaccountsRequestPayloadCollection is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.moveSubaccountsRequestPayloadCollection
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSubaccountRequest struct {
	ctx context.Context
	ApiService SubaccountOperationsAPI
	subaccountGUID string
	updateSubaccountRequestPayload *UpdateSubaccountRequestPayload
}

func (r ApiUpdateSubaccountRequest) UpdateSubaccountRequestPayload(updateSubaccountRequestPayload UpdateSubaccountRequestPayload) ApiUpdateSubaccountRequest {
	r.updateSubaccountRequestPayload = &updateSubaccountRequestPayload
	return r
}

func (r ApiUpdateSubaccountRequest) Execute() (*SubaccountResponseObject, *http.Response, error) {
	return r.ApiService.UpdateSubaccountExecute(r)
}

/*
UpdateSubaccount Update a subaccount

Update a subaccount in the global account.<br/><br/>Required scope: $XSAPPNAME.global-account.subaccount.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subaccountGUID The GUID of the subaccount to update.
 @return ApiUpdateSubaccountRequest
*/
func (a *SubaccountOperationsAPIService) UpdateSubaccount(ctx context.Context, subaccountGUID string) ApiUpdateSubaccountRequest {
	return ApiUpdateSubaccountRequest{
		ApiService: a,
		ctx: ctx,
		subaccountGUID: subaccountGUID,
	}
}

// Execute executes the request
//  @return SubaccountResponseObject
func (a *SubaccountOperationsAPIService) UpdateSubaccountExecute(r ApiUpdateSubaccountRequest) (*SubaccountResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubaccountResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubaccountOperationsAPIService.UpdateSubaccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/v1/subaccounts/{subaccountGUID}"
	localVarPath = strings.Replace(localVarPath, "{"+"subaccountGUID"+"}", url.PathEscape(parameterValueToString(r.subaccountGUID, "subaccountGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateSubaccountRequestPayload == nil {
		return localVarReturnValue, nil, reportError("updateSubaccountRequestPayload is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateSubaccountRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
