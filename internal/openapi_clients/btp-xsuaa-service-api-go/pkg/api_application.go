/*
SAP XSUAA REST API

Provides access to RoleTemplates, Roles, RoleCollection etc. using the XSUAA REST API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ApplicationAPI interface {

	/*
	GetAppById Returns information about an XSUAA application instance.

	Returns information about an XSUAA application instance specified by the app ID or service instance ID. The XSUAA application instance paired with an OAuth client defines a service instance of the Authorization and Trust Management service.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the application or service instance. To use service instance ID, set the parameter to true.
	@return ApplicationAPIGetAppByIdRequest
	*/
	GetAppById(ctx context.Context, id string) ApplicationAPIGetAppByIdRequest

	// GetAppByIdExecute executes the request
	//  @return App
	GetAppByIdExecute(r ApplicationAPIGetAppByIdRequest) (*App, *http.Response, error)

	/*
	GetAppByToken Returns usage information for the service instance which is used to execute API access.

	Returns the number of subscribers for the service instance which is associated with the client credentials you submitted with this REST call.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApplicationAPIGetAppByTokenRequest
	*/
	GetAppByToken(ctx context.Context) ApplicationAPIGetAppByTokenRequest

	// GetAppByTokenExecute executes the request
	//  @return map[string]map[string]interface{}
	GetAppByTokenExecute(r ApplicationAPIGetAppByTokenRequest) (map[string]map[string]interface{}, *http.Response, error)

	/*
	GetApps Returns registered service instances of the current subaccount.

	Returns all service instances of the current subaccount which are registered at the Authorization and Trust Management service as OAuth 2.0 clients. The system provides information about the XSUAA application and its OAuth client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApplicationAPIGetAppsRequest
	*/
	GetApps(ctx context.Context) ApplicationAPIGetAppsRequest

	// GetAppsExecute executes the request
	//  @return []App
	GetAppsExecute(r ApplicationAPIGetAppsRequest) ([]App, *http.Response, error)

	/*
	GetGrantedAuthorities Returns a list of authorities granted to an application.

	Returns a list of authorities that have been granted to an application. <ul><li>The granting application is identified by the <var>grantedByAppGuid</var> or <var>grantedByAppId</var> parameter. If no granting application is specified the list will be empty.</li><li>The request has to be authenticated with a JWT obtained via the client credentials grant from the granted application. The JWT has to include the <var>uaa.resource</var> scope.</li></ul>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appId Application ID
	@return ApplicationAPIGetGrantedAuthoritiesRequest
	*/
	GetGrantedAuthorities(ctx context.Context, appId string) ApplicationAPIGetGrantedAuthoritiesRequest

	// GetGrantedAuthoritiesExecute executes the request
	//  @return []string
	GetGrantedAuthoritiesExecute(r ApplicationAPIGetGrantedAuthoritiesRequest) ([]string, *http.Response, error)

	/*
	GetOwnApp Returns information about the service instance used to execute this API access.

	Returns information about the service instance which is associated with the client credentials you submitted with this REST call.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApplicationAPIGetOwnAppRequest
	*/
	GetOwnApp(ctx context.Context) ApplicationAPIGetOwnAppRequest

	// GetOwnAppExecute executes the request
	//  @return App
	GetOwnAppExecute(r ApplicationAPIGetOwnAppRequest) (*App, *http.Response, error)

	/*
	GetRoleCollectionsByAppIdTemplateNameAndRoleName Get RoleCollections containing a role identified by appId, roleTemplateName and role name

	Retrieve all RoleCollections containing a role. The role is identified by appId, roleTemplateName and role name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appId Application ID
	@param roleTemplateName Name of the Role Template
	@param roleName Name of the Role
	@return ApplicationAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest
	*/
	GetRoleCollectionsByAppIdTemplateNameAndRoleName(ctx context.Context, appId string, roleTemplateName string, roleName string) ApplicationAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest

	// GetRoleCollectionsByAppIdTemplateNameAndRoleNameExecute executes the request
	//  @return []RoleCollection
	GetRoleCollectionsByAppIdTemplateNameAndRoleNameExecute(r ApplicationAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest) ([]RoleCollection, *http.Response, error)

	/*
	GetScope Returns the scope of an application.

	Returns information about a specific scope of a specific application.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appId Application ID
	@param scopeName Name of the scope
	@return ApplicationAPIGetScopeRequest
	*/
	GetScope(ctx context.Context, appId string, scopeName string) ApplicationAPIGetScopeRequest

	// GetScopeExecute executes the request
	//  @return Scope
	GetScopeExecute(r ApplicationAPIGetScopeRequest) (*Scope, *http.Response, error)

	/*
	ListScopes Returns the scopes of an application.

	Returns all scopes of an application protected by a service instance of the Authorization and Trust Management service.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appId Application ID
	@return ApplicationAPIListScopesRequest
	*/
	ListScopes(ctx context.Context, appId string) ApplicationAPIListScopesRequest

	// ListScopesExecute executes the request
	//  @return []Scope
	ListScopesExecute(r ApplicationAPIListScopesRequest) ([]Scope, *http.Response, error)
}

// ApplicationAPIService ApplicationAPI service
type ApplicationAPIService service

type ApplicationAPIGetAppByIdRequest struct {
	ctx context.Context
	ApiService ApplicationAPI
	id string
	isServiceInstanceId *bool
	hideDetails *bool
}

// If the parameter is set to true, the ID set in the path is interpreted as the service instance ID and not the XSUAA application instance ID.
func (r ApplicationAPIGetAppByIdRequest) IsServiceInstanceId(isServiceInstanceId bool) ApplicationAPIGetAppByIdRequest {
	r.isServiceInstanceId = &isServiceInstanceId
	return r
}

// The ID of the application or service instance. To use service instance ID, set the isServiceInstanceId parameter to true.
func (r ApplicationAPIGetAppByIdRequest) HideDetails(hideDetails bool) ApplicationAPIGetAppByIdRequest {
	r.hideDetails = &hideDetails
	return r
}

func (r ApplicationAPIGetAppByIdRequest) Execute() (*App, *http.Response, error) {
	return r.ApiService.GetAppByIdExecute(r)
}

/*
GetAppById Returns information about an XSUAA application instance.

Returns information about an XSUAA application instance specified by the app ID or service instance ID. The XSUAA application instance paired with an OAuth client defines a service instance of the Authorization and Trust Management service.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the application or service instance. To use service instance ID, set the parameter to true.
 @return ApplicationAPIGetAppByIdRequest
*/
func (a *ApplicationAPIService) GetAppById(ctx context.Context, id string) ApplicationAPIGetAppByIdRequest {
	return ApplicationAPIGetAppByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return App
func (a *ApplicationAPIService) GetAppByIdExecute(r ApplicationAPIGetAppByIdRequest) (*App, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *App
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.GetAppById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isServiceInstanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isServiceInstanceId", r.isServiceInstanceId, "form", "")
	}
	if r.hideDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hideDetails", r.hideDetails, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v App
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v App
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v App
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v App
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationAPIGetAppByTokenRequest struct {
	ctx context.Context
	ApiService ApplicationAPI
	tenant *string
	zoneid *string
	listSubscriptions *bool
	listCloneSubscriptions *bool
}

// Tenant ID
func (r ApplicationAPIGetAppByTokenRequest) Tenant(tenant string) ApplicationAPIGetAppByTokenRequest {
	r.tenant = &tenant
	return r
}

// Zone ID
func (r ApplicationAPIGetAppByTokenRequest) Zoneid(zoneid string) ApplicationAPIGetAppByTokenRequest {
	r.zoneid = &zoneid
	return r
}

// Include subscriptions
func (r ApplicationAPIGetAppByTokenRequest) ListSubscriptions(listSubscriptions bool) ApplicationAPIGetAppByTokenRequest {
	r.listSubscriptions = &listSubscriptions
	return r
}

// Include clone subscriptions
func (r ApplicationAPIGetAppByTokenRequest) ListCloneSubscriptions(listCloneSubscriptions bool) ApplicationAPIGetAppByTokenRequest {
	r.listCloneSubscriptions = &listCloneSubscriptions
	return r
}

func (r ApplicationAPIGetAppByTokenRequest) Execute() (map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetAppByTokenExecute(r)
}

/*
GetAppByToken Returns usage information for the service instance which is used to execute API access.

Returns the number of subscribers for the service instance which is associated with the client credentials you submitted with this REST call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApplicationAPIGetAppByTokenRequest
*/
func (a *ApplicationAPIService) GetAppByToken(ctx context.Context) ApplicationAPIGetAppByTokenRequest {
	return ApplicationAPIGetAppByTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *ApplicationAPIService) GetAppByTokenExecute(r ApplicationAPIGetAppByTokenRequest) (map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.GetAppByToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/ownapp/usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tenant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenant", r.tenant, "form", "")
	}
	if r.zoneid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "zoneid", r.zoneid, "form", "")
	}
	if r.listSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listSubscriptions", r.listSubscriptions, "form", "")
	} else {
		var defaultValue bool = false
		r.listSubscriptions = &defaultValue
	}
	if r.listCloneSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listCloneSubscriptions", r.listCloneSubscriptions, "form", "")
	} else {
		var defaultValue bool = false
		r.listCloneSubscriptions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationAPIGetAppsRequest struct {
	ctx context.Context
	ApiService ApplicationAPI
	onlyWithClientId *bool
	onlyForOrgId *string
	onlyForSubaccountId *string
	onlyForXsappname *string
}

// OAuth client filter: If set to false only apps are returned that are not associated with an OAuth client. The filter is of type boolean.
func (r ApplicationAPIGetAppsRequest) OnlyWithClientId(onlyWithClientId bool) ApplicationAPIGetAppsRequest {
	r.onlyWithClientId = &onlyWithClientId
	return r
}

// CF organizations filter: Only apps that reside in the specified Cloud Foundry org are returned. The CF org is specified by its GUID.
func (r ApplicationAPIGetAppsRequest) OnlyForOrgId(onlyForOrgId string) ApplicationAPIGetAppsRequest {
	r.onlyForOrgId = &onlyForOrgId
	return r
}

// Subaccount filter: Only apps that reside in the specified subaccount are returned. The subaccount is specified by its id.
func (r ApplicationAPIGetAppsRequest) OnlyForSubaccountId(onlyForSubaccountId string) ApplicationAPIGetAppsRequest {
	r.onlyForSubaccountId = &onlyForSubaccountId
	return r
}

// XSAppName filter: Only apps with the specified name are returned. The name is the xsappname of the application.
func (r ApplicationAPIGetAppsRequest) OnlyForXsappname(onlyForXsappname string) ApplicationAPIGetAppsRequest {
	r.onlyForXsappname = &onlyForXsappname
	return r
}

func (r ApplicationAPIGetAppsRequest) Execute() ([]App, *http.Response, error) {
	return r.ApiService.GetAppsExecute(r)
}

/*
GetApps Returns registered service instances of the current subaccount.

Returns all service instances of the current subaccount which are registered at the Authorization and Trust Management service as OAuth 2.0 clients. The system provides information about the XSUAA application and its OAuth client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApplicationAPIGetAppsRequest
*/
func (a *ApplicationAPIService) GetApps(ctx context.Context) ApplicationAPIGetAppsRequest {
	return ApplicationAPIGetAppsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []App
func (a *ApplicationAPIService) GetAppsExecute(r ApplicationAPIGetAppsRequest) ([]App, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []App
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.GetApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.onlyWithClientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyWithClientId", r.onlyWithClientId, "form", "")
	}
	if r.onlyForOrgId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyForOrgId", r.onlyForOrgId, "form", "")
	}
	if r.onlyForSubaccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyForSubaccountId", r.onlyForSubaccountId, "form", "")
	}
	if r.onlyForXsappname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyForXsappname", r.onlyForXsappname, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []App
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []App
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []App
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationAPIGetGrantedAuthoritiesRequest struct {
	ctx context.Context
	ApiService ApplicationAPI
	appId string
	grantedByAppGuid *string
	grantedByAppId *string
}

// appUid of authority
func (r ApplicationAPIGetGrantedAuthoritiesRequest) GrantedByAppGuid(grantedByAppGuid string) ApplicationAPIGetGrantedAuthoritiesRequest {
	r.grantedByAppGuid = &grantedByAppGuid
	return r
}

// AppID of authority
func (r ApplicationAPIGetGrantedAuthoritiesRequest) GrantedByAppId(grantedByAppId string) ApplicationAPIGetGrantedAuthoritiesRequest {
	r.grantedByAppId = &grantedByAppId
	return r
}

func (r ApplicationAPIGetGrantedAuthoritiesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetGrantedAuthoritiesExecute(r)
}

/*
GetGrantedAuthorities Returns a list of authorities granted to an application.

Returns a list of authorities that have been granted to an application. <ul><li>The granting application is identified by the <var>grantedByAppGuid</var> or <var>grantedByAppId</var> parameter. If no granting application is specified the list will be empty.</li><li>The request has to be authenticated with a JWT obtained via the client credentials grant from the granted application. The JWT has to include the <var>uaa.resource</var> scope.</li></ul>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId Application ID
 @return ApplicationAPIGetGrantedAuthoritiesRequest
*/
func (a *ApplicationAPIService) GetGrantedAuthorities(ctx context.Context, appId string) ApplicationAPIGetGrantedAuthoritiesRequest {
	return ApplicationAPIGetGrantedAuthoritiesRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
	}
}

// Execute executes the request
//  @return []string
func (a *ApplicationAPIService) GetGrantedAuthoritiesExecute(r ApplicationAPIGetGrantedAuthoritiesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.GetGrantedAuthorities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/apps/{appId}/authorities"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.grantedByAppGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "grantedByAppGuid", r.grantedByAppGuid, "form", "")
	}
	if r.grantedByAppId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "grantedByAppId", r.grantedByAppId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationAPIGetOwnAppRequest struct {
	ctx context.Context
	ApiService ApplicationAPI
}

func (r ApplicationAPIGetOwnAppRequest) Execute() (*App, *http.Response, error) {
	return r.ApiService.GetOwnAppExecute(r)
}

/*
GetOwnApp Returns information about the service instance used to execute this API access.

Returns information about the service instance which is associated with the client credentials you submitted with this REST call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApplicationAPIGetOwnAppRequest
*/
func (a *ApplicationAPIService) GetOwnApp(ctx context.Context) ApplicationAPIGetOwnAppRequest {
	return ApplicationAPIGetOwnAppRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return App
func (a *ApplicationAPIService) GetOwnAppExecute(r ApplicationAPIGetOwnAppRequest) (*App, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *App
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.GetOwnApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/ownapp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v App
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v App
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v App
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest struct {
	ctx context.Context
	ApiService ApplicationAPI
	appId string
	roleTemplateName string
	roleName string
}

func (r ApplicationAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest) Execute() ([]RoleCollection, *http.Response, error) {
	return r.ApiService.GetRoleCollectionsByAppIdTemplateNameAndRoleNameExecute(r)
}

/*
GetRoleCollectionsByAppIdTemplateNameAndRoleName Get RoleCollections containing a role identified by appId, roleTemplateName and role name

Retrieve all RoleCollections containing a role. The role is identified by appId, roleTemplateName and role name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId Application ID
 @param roleTemplateName Name of the Role Template
 @param roleName Name of the Role
 @return ApplicationAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest
*/
func (a *ApplicationAPIService) GetRoleCollectionsByAppIdTemplateNameAndRoleName(ctx context.Context, appId string, roleTemplateName string, roleName string) ApplicationAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest {
	return ApplicationAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
		roleTemplateName: roleTemplateName,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleCollection
func (a *ApplicationAPIService) GetRoleCollectionsByAppIdTemplateNameAndRoleNameExecute(r ApplicationAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest) ([]RoleCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.GetRoleCollectionsByAppIdTemplateNameAndRoleName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/roles/{appId}/{roleTemplateName}/{roleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleTemplateName"+"}", url.PathEscape(parameterValueToString(r.roleTemplateName, "roleTemplateName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleName"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationAPIGetScopeRequest struct {
	ctx context.Context
	ApiService ApplicationAPI
	appId string
	scopeName string
}

func (r ApplicationAPIGetScopeRequest) Execute() (*Scope, *http.Response, error) {
	return r.ApiService.GetScopeExecute(r)
}

/*
GetScope Returns the scope of an application.

Returns information about a specific scope of a specific application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId Application ID
 @param scopeName Name of the scope
 @return ApplicationAPIGetScopeRequest
*/
func (a *ApplicationAPIService) GetScope(ctx context.Context, appId string, scopeName string) ApplicationAPIGetScopeRequest {
	return ApplicationAPIGetScopeRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
		scopeName: scopeName,
	}
}

// Execute executes the request
//  @return Scope
func (a *ApplicationAPIService) GetScopeExecute(r ApplicationAPIGetScopeRequest) (*Scope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Scope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.GetScope")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/apps/{appId}/scopes/{scopeName}"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scopeName"+"}", url.PathEscape(parameterValueToString(r.scopeName, "scopeName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Scope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Scope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Scope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApplicationAPIListScopesRequest struct {
	ctx context.Context
	ApiService ApplicationAPI
	appId string
}

func (r ApplicationAPIListScopesRequest) Execute() ([]Scope, *http.Response, error) {
	return r.ApiService.ListScopesExecute(r)
}

/*
ListScopes Returns the scopes of an application.

Returns all scopes of an application protected by a service instance of the Authorization and Trust Management service.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId Application ID
 @return ApplicationAPIListScopesRequest
*/
func (a *ApplicationAPIService) ListScopes(ctx context.Context, appId string) ApplicationAPIListScopesRequest {
	return ApplicationAPIListScopesRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
	}
}

// Execute executes the request
//  @return []Scope
func (a *ApplicationAPIService) ListScopesExecute(r ApplicationAPIListScopesRequest) ([]Scope, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Scope
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationAPIService.ListScopes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/apps/{appId}/scopes"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []Scope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []Scope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []Scope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
