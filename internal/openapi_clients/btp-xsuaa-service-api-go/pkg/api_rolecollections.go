/*
SAP XSUAA REST API

Provides access to RoleTemplates, Roles, RoleCollection etc. using the XSUAA REST API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type RolecollectionsAPI interface {

	/*
	AddRoleToRoleCollection Adds a role to role a collection.

	Adds a role reference, specified by role name, application ID, and role template name, to a role collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleCollectionName The name of the role collection to update.
	@param roleTemplateAppID The application ID, with which the role is associated.
	@param roleName The name of the role to add to the role collection.
	@param roleTemplateName The name of the role template, with which the role is associated.
	@return RolecollectionsAPIAddRoleToRoleCollectionRequest
	*/
	AddRoleToRoleCollection(ctx context.Context, roleCollectionName string, roleTemplateAppID string, roleName string, roleTemplateName string) RolecollectionsAPIAddRoleToRoleCollectionRequest

	// AddRoleToRoleCollectionExecute executes the request
	//  @return map[string]interface{}
	AddRoleToRoleCollectionExecute(r RolecollectionsAPIAddRoleToRoleCollectionRequest) (map[string]interface{}, *http.Response, error)

	/*
	AddRolesToRoleCollection Add roles to role collection.

	Updates a role collection with an array of roles. Specify the roles by role name, application ID, and role template name. These roles are added to the roles already included in the role collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleCollectionName Name of the role collection
	@return RolecollectionsAPIAddRolesToRoleCollectionRequest
	*/
	AddRolesToRoleCollection(ctx context.Context, roleCollectionName string) RolecollectionsAPIAddRolesToRoleCollectionRequest

	// AddRolesToRoleCollectionExecute executes the request
	//  @return map[string]interface{}
	AddRolesToRoleCollectionExecute(r RolecollectionsAPIAddRolesToRoleCollectionRequest) (map[string]interface{}, *http.Response, error)

	/*
	ChangeRoleCollectionDescription Updates the description of a role collection.

	Updates the description of a role collection specified by the name of the role collection. You cannot change any other attribute of the role collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleCollectionName Name of the role collection
	@return RolecollectionsAPIChangeRoleCollectionDescriptionRequest
	*/
	ChangeRoleCollectionDescription(ctx context.Context, roleCollectionName string) RolecollectionsAPIChangeRoleCollectionDescriptionRequest

	// ChangeRoleCollectionDescriptionExecute executes the request
	//  @return map[string]interface{}
	ChangeRoleCollectionDescriptionExecute(r RolecollectionsAPIChangeRoleCollectionDescriptionRequest) (map[string]interface{}, *http.Response, error)

	/*
	CreateRoleCollection Creates a role collection.

	Creates a role collection. You must include a role name at a minimum. The description is created as null if you do not include one. You can include role references as defined by the role name, the application ID, and role template name. To assign group members use the /Groups endpoint. Groups are mapped to role collections in the Authorization and Trust Management service.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RolecollectionsAPICreateRoleCollectionRequest
	*/
	CreateRoleCollection(ctx context.Context) RolecollectionsAPICreateRoleCollectionRequest

	// CreateRoleCollectionExecute executes the request
	//  @return RoleCollection
	CreateRoleCollectionExecute(r RolecollectionsAPICreateRoleCollectionRequest) (*RoleCollection, *http.Response, error)

	/*
	CreateRoleCollections Bulk creation of role collections.

	Bulk create of role collections specified by the name of the role collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RolecollectionsAPICreateRoleCollectionsRequest
	*/
	CreateRoleCollections(ctx context.Context) RolecollectionsAPICreateRoleCollectionsRequest

	// CreateRoleCollectionsExecute executes the request
	//  @return map[string]map[string]interface{}
	CreateRoleCollectionsExecute(r RolecollectionsAPICreateRoleCollectionsRequest) (map[string]map[string]interface{}, *http.Response, error)

	/*
	CreateRoleCollectionsForUser Create bulk role collections for a User

	create role collections for a user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RolecollectionsAPICreateRoleCollectionsForUserRequest
	*/
	CreateRoleCollectionsForUser(ctx context.Context) RolecollectionsAPICreateRoleCollectionsForUserRequest

	// CreateRoleCollectionsForUserExecute executes the request
	//  @return RoleCollectionListDto
	CreateRoleCollectionsForUserExecute(r RolecollectionsAPICreateRoleCollectionsForUserRequest) (*RoleCollectionListDto, *http.Response, error)

	/*
	DeleteRoleCollectionByName Deletes a role collection.

	Deletes a role collection specified by the name of the role collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleCollectionName Name of collection to be retrieved
	@return RolecollectionsAPIDeleteRoleCollectionByNameRequest
	*/
	DeleteRoleCollectionByName(ctx context.Context, roleCollectionName string) RolecollectionsAPIDeleteRoleCollectionByNameRequest

	// DeleteRoleCollectionByNameExecute executes the request
	//  @return map[string]interface{}
	DeleteRoleCollectionByNameExecute(r RolecollectionsAPIDeleteRoleCollectionByNameRequest) (map[string]interface{}, *http.Response, error)

	/*
	DeleteRoleCollections Bulk delete of role collections.

	Bulk delete of role collections specified by the name of the role collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RolecollectionsAPIDeleteRoleCollectionsRequest
	*/
	DeleteRoleCollections(ctx context.Context) RolecollectionsAPIDeleteRoleCollectionsRequest

	// DeleteRoleCollectionsExecute executes the request
	DeleteRoleCollectionsExecute(r RolecollectionsAPIDeleteRoleCollectionsRequest) (*http.Response, error)

	/*
	DeleteRoleCollectionsForUser Delete bulk role collections of User

	delete role collections for a user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RolecollectionsAPIDeleteRoleCollectionsForUserRequest
	*/
	DeleteRoleCollectionsForUser(ctx context.Context) RolecollectionsAPIDeleteRoleCollectionsForUserRequest

	// DeleteRoleCollectionsForUserExecute executes the request
	DeleteRoleCollectionsForUserExecute(r RolecollectionsAPIDeleteRoleCollectionsForUserRequest) (*http.Response, error)

	/*
	DeleteRoleFromRoleCollection Deletes a role from a role collection.

	Deletes a role specified by the role reference from a role collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleCollectionName Name of the role collection
	@param roleTemplateAppID AppID of the Role Template
	@param roleName Name of the Role
	@param roleTemplateName Name of the Role Template
	@return RolecollectionsAPIDeleteRoleFromRoleCollectionRequest
	*/
	DeleteRoleFromRoleCollection(ctx context.Context, roleCollectionName string, roleTemplateAppID string, roleName string, roleTemplateName string) RolecollectionsAPIDeleteRoleFromRoleCollectionRequest

	// DeleteRoleFromRoleCollectionExecute executes the request
	//  @return map[string]interface{}
	DeleteRoleFromRoleCollectionExecute(r RolecollectionsAPIDeleteRoleFromRoleCollectionRequest) (map[string]interface{}, *http.Response, error)

	/*
	DeleteRolesFromRoleCollection Remove roles from role collection.

	Updates a role collection by removing an array of roles from role collection. Specify the roles by role name, application ID, and role template name. These roles are removed from the role collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleCollectionName Name of the role collection
	@return RolecollectionsAPIDeleteRolesFromRoleCollectionRequest
	*/
	DeleteRolesFromRoleCollection(ctx context.Context, roleCollectionName string) RolecollectionsAPIDeleteRolesFromRoleCollectionRequest

	// DeleteRolesFromRoleCollectionExecute executes the request
	//  @return map[string]interface{}
	DeleteRolesFromRoleCollectionExecute(r RolecollectionsAPIDeleteRolesFromRoleCollectionRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetRoleCollectionByName Returns a role collection.

	Returns information about a role collection identified by the name of the role collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleCollectionName Name of collection to be retrieved
	@return RolecollectionsAPIGetRoleCollectionByNameRequest
	*/
	GetRoleCollectionByName(ctx context.Context, roleCollectionName string) RolecollectionsAPIGetRoleCollectionByNameRequest

	// GetRoleCollectionByNameExecute executes the request
	//  @return RoleCollection
	GetRoleCollectionByNameExecute(r RolecollectionsAPIGetRoleCollectionByNameRequest) (*RoleCollection, *http.Response, error)

	/*
	GetRoleCollections Returns role collections.

	Returns all role collections which exist within the current subaccount, sorted alphabetically by their names.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RolecollectionsAPIGetRoleCollectionsRequest
	*/
	GetRoleCollections(ctx context.Context) RolecollectionsAPIGetRoleCollectionsRequest

	// GetRoleCollectionsExecute executes the request
	//  @return []RoleCollection
	GetRoleCollectionsExecute(r RolecollectionsAPIGetRoleCollectionsRequest) ([]RoleCollection, *http.Response, error)

	/*
	GetRoleCollectionsByAppIdTemplateNameAndRoleName Get RoleCollections containing a role identified by appId, roleTemplateName and role name

	Retrieve all RoleCollections containing a role. The role is identified by appId, roleTemplateName and role name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appId Application ID
	@param roleTemplateName Name of the Role Template
	@param roleName Name of the Role
	@return RolecollectionsAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest
	*/
	GetRoleCollectionsByAppIdTemplateNameAndRoleName(ctx context.Context, appId string, roleTemplateName string, roleName string) RolecollectionsAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest

	// GetRoleCollectionsByAppIdTemplateNameAndRoleNameExecute executes the request
	//  @return []RoleCollection
	GetRoleCollectionsByAppIdTemplateNameAndRoleNameExecute(r RolecollectionsAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest) ([]RoleCollection, *http.Response, error)

	/*
	GetRoleCollectionsByPaging Returns a page of role collections.

	Returns the specified page of role collection search result. The role collections are the result of a previous paged GET request for role collections of the current subaccount.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pageId Page Id
	@return RolecollectionsAPIGetRoleCollectionsByPagingRequest
	*/
	GetRoleCollectionsByPaging(ctx context.Context, pageId int32) RolecollectionsAPIGetRoleCollectionsByPagingRequest

	// GetRoleCollectionsByPagingExecute executes the request
	//  @return []RoleCollection
	GetRoleCollectionsByPagingExecute(r RolecollectionsAPIGetRoleCollectionsByPagingRequest) ([]RoleCollection, *http.Response, error)

	/*
	GetRoleCollectionsByPaging1 Returns a page of role collections.

	Returns the specified page of role collection search result. The role collections are the result of a previous paged GET request for role collections of the current subaccount.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pageId Page Id
	@return RolecollectionsAPIGetRoleCollectionsByPaging1Request
	*/
	GetRoleCollectionsByPaging1(ctx context.Context, pageId int32) RolecollectionsAPIGetRoleCollectionsByPaging1Request

	// GetRoleCollectionsByPaging1Execute executes the request
	//  @return []RoleCollection
	GetRoleCollectionsByPaging1Execute(r RolecollectionsAPIGetRoleCollectionsByPaging1Request) ([]RoleCollection, *http.Response, error)

	/*
	GetRoleCollectionsByPaging2 Returns a page of role collections.

	Returns the specified page of role collection search result. The role collections are the result of a previous paged GET request for role collections of the current subaccount.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param pageId Page Id
	@return RolecollectionsAPIGetRoleCollectionsByPaging2Request
	*/
	GetRoleCollectionsByPaging2(ctx context.Context, pageId int32) RolecollectionsAPIGetRoleCollectionsByPaging2Request

	// GetRoleCollectionsByPaging2Execute executes the request
	//  @return []RoleCollection
	GetRoleCollectionsByPaging2Execute(r RolecollectionsAPIGetRoleCollectionsByPaging2Request) ([]RoleCollection, *http.Response, error)

	/*
	GetRoleCollectionsForUser Get role collections of User

	all role collections for a user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId User ID
	@return RolecollectionsAPIGetRoleCollectionsForUserRequest
	*/
	GetRoleCollectionsForUser(ctx context.Context, userId string) RolecollectionsAPIGetRoleCollectionsForUserRequest

	// GetRoleCollectionsForUserExecute executes the request
	//  @return RoleCollectionListDto
	GetRoleCollectionsForUserExecute(r RolecollectionsAPIGetRoleCollectionsForUserRequest) (*RoleCollectionListDto, *http.Response, error)

	/*
	GetRoleCollectionsForUser1 Get role collections of User

	all role collections for a user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId User ID
	@return RolecollectionsAPIGetRoleCollectionsForUser1Request
	*/
	GetRoleCollectionsForUser1(ctx context.Context, userId string) RolecollectionsAPIGetRoleCollectionsForUser1Request

	// GetRoleCollectionsForUser1Execute executes the request
	//  @return RoleCollectionListDto
	GetRoleCollectionsForUser1Execute(r RolecollectionsAPIGetRoleCollectionsForUser1Request) (*RoleCollectionListDto, *http.Response, error)

	/*
	GetRolesByRoleCollectionName Returns the roles of a role collection.

	Returns information about the roles of a role collection specified by the name of the role collection.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param roleCollectionName Name of the role collection
	@return RolecollectionsAPIGetRolesByRoleCollectionNameRequest
	*/
	GetRolesByRoleCollectionName(ctx context.Context, roleCollectionName string) RolecollectionsAPIGetRolesByRoleCollectionNameRequest

	// GetRolesByRoleCollectionNameExecute executes the request
	//  @return []Role
	GetRolesByRoleCollectionNameExecute(r RolecollectionsAPIGetRolesByRoleCollectionNameRequest) ([]Role, *http.Response, error)
}

// RolecollectionsAPIService RolecollectionsAPI service
type RolecollectionsAPIService service

type RolecollectionsAPIAddRoleToRoleCollectionRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollectionName string
	roleTemplateAppID string
	roleName string
	roleTemplateName string
}

func (r RolecollectionsAPIAddRoleToRoleCollectionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AddRoleToRoleCollectionExecute(r)
}

/*
AddRoleToRoleCollection Adds a role to role a collection.

Adds a role reference, specified by role name, application ID, and role template name, to a role collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleCollectionName The name of the role collection to update.
 @param roleTemplateAppID The application ID, with which the role is associated.
 @param roleName The name of the role to add to the role collection.
 @param roleTemplateName The name of the role template, with which the role is associated.
 @return RolecollectionsAPIAddRoleToRoleCollectionRequest
*/
func (a *RolecollectionsAPIService) AddRoleToRoleCollection(ctx context.Context, roleCollectionName string, roleTemplateAppID string, roleName string, roleTemplateName string) RolecollectionsAPIAddRoleToRoleCollectionRequest {
	return RolecollectionsAPIAddRoleToRoleCollectionRequest{
		ApiService: a,
		ctx: ctx,
		roleCollectionName: roleCollectionName,
		roleTemplateAppID: roleTemplateAppID,
		roleName: roleName,
		roleTemplateName: roleTemplateName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RolecollectionsAPIService) AddRoleToRoleCollectionExecute(r RolecollectionsAPIAddRoleToRoleCollectionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.AddRoleToRoleCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/{roleCollectionName}/roles/{roleTemplateAppID}/{roleName}/{roleTemplateName}"
	localVarPath = strings.Replace(localVarPath, "{"+"roleCollectionName"+"}", url.PathEscape(parameterValueToString(r.roleCollectionName, "roleCollectionName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleTemplateAppID"+"}", url.PathEscape(parameterValueToString(r.roleTemplateAppID, "roleTemplateAppID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleName"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleTemplateName"+"}", url.PathEscape(parameterValueToString(r.roleTemplateName, "roleTemplateName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIAddRolesToRoleCollectionRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollectionName string
	roleReference *[]RoleReference
}

func (r RolecollectionsAPIAddRolesToRoleCollectionRequest) RoleReference(roleReference []RoleReference) RolecollectionsAPIAddRolesToRoleCollectionRequest {
	r.roleReference = &roleReference
	return r
}

func (r RolecollectionsAPIAddRolesToRoleCollectionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AddRolesToRoleCollectionExecute(r)
}

/*
AddRolesToRoleCollection Add roles to role collection.

Updates a role collection with an array of roles. Specify the roles by role name, application ID, and role template name. These roles are added to the roles already included in the role collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleCollectionName Name of the role collection
 @return RolecollectionsAPIAddRolesToRoleCollectionRequest
*/
func (a *RolecollectionsAPIService) AddRolesToRoleCollection(ctx context.Context, roleCollectionName string) RolecollectionsAPIAddRolesToRoleCollectionRequest {
	return RolecollectionsAPIAddRolesToRoleCollectionRequest{
		ApiService: a,
		ctx: ctx,
		roleCollectionName: roleCollectionName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RolecollectionsAPIService) AddRolesToRoleCollectionExecute(r RolecollectionsAPIAddRolesToRoleCollectionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.AddRolesToRoleCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/{roleCollectionName}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"roleCollectionName"+"}", url.PathEscape(parameterValueToString(r.roleCollectionName, "roleCollectionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleReference == nil {
		return localVarReturnValue, nil, reportError("roleReference is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIChangeRoleCollectionDescriptionRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollectionName string
	roleCollectionDescription *RoleCollectionDescription
}

func (r RolecollectionsAPIChangeRoleCollectionDescriptionRequest) RoleCollectionDescription(roleCollectionDescription RoleCollectionDescription) RolecollectionsAPIChangeRoleCollectionDescriptionRequest {
	r.roleCollectionDescription = &roleCollectionDescription
	return r
}

func (r RolecollectionsAPIChangeRoleCollectionDescriptionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ChangeRoleCollectionDescriptionExecute(r)
}

/*
ChangeRoleCollectionDescription Updates the description of a role collection.

Updates the description of a role collection specified by the name of the role collection. You cannot change any other attribute of the role collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleCollectionName Name of the role collection
 @return RolecollectionsAPIChangeRoleCollectionDescriptionRequest
*/
func (a *RolecollectionsAPIService) ChangeRoleCollectionDescription(ctx context.Context, roleCollectionName string) RolecollectionsAPIChangeRoleCollectionDescriptionRequest {
	return RolecollectionsAPIChangeRoleCollectionDescriptionRequest{
		ApiService: a,
		ctx: ctx,
		roleCollectionName: roleCollectionName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RolecollectionsAPIService) ChangeRoleCollectionDescriptionExecute(r RolecollectionsAPIChangeRoleCollectionDescriptionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.ChangeRoleCollectionDescription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/{roleCollectionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"roleCollectionName"+"}", url.PathEscape(parameterValueToString(r.roleCollectionName, "roleCollectionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleCollectionDescription == nil {
		return localVarReturnValue, nil, reportError("roleCollectionDescription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleCollectionDescription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPICreateRoleCollectionRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollection *RoleCollection
}

func (r RolecollectionsAPICreateRoleCollectionRequest) RoleCollection(roleCollection RoleCollection) RolecollectionsAPICreateRoleCollectionRequest {
	r.roleCollection = &roleCollection
	return r
}

func (r RolecollectionsAPICreateRoleCollectionRequest) Execute() (*RoleCollection, *http.Response, error) {
	return r.ApiService.CreateRoleCollectionExecute(r)
}

/*
CreateRoleCollection Creates a role collection.

Creates a role collection. You must include a role name at a minimum. The description is created as null if you do not include one. You can include role references as defined by the role name, the application ID, and role template name. To assign group members use the /Groups endpoint. Groups are mapped to role collections in the Authorization and Trust Management service.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RolecollectionsAPICreateRoleCollectionRequest
*/
func (a *RolecollectionsAPIService) CreateRoleCollection(ctx context.Context) RolecollectionsAPICreateRoleCollectionRequest {
	return RolecollectionsAPICreateRoleCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoleCollection
func (a *RolecollectionsAPIService) CreateRoleCollectionExecute(r RolecollectionsAPICreateRoleCollectionRequest) (*RoleCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoleCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.CreateRoleCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleCollection == nil {
		return localVarReturnValue, nil, reportError("roleCollection is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleCollection
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPICreateRoleCollectionsRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollectionsBulkDto *RoleCollectionsBulkDto
}

func (r RolecollectionsAPICreateRoleCollectionsRequest) RoleCollectionsBulkDto(roleCollectionsBulkDto RoleCollectionsBulkDto) RolecollectionsAPICreateRoleCollectionsRequest {
	r.roleCollectionsBulkDto = &roleCollectionsBulkDto
	return r
}

func (r RolecollectionsAPICreateRoleCollectionsRequest) Execute() (map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateRoleCollectionsExecute(r)
}

/*
CreateRoleCollections Bulk creation of role collections.

Bulk create of role collections specified by the name of the role collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RolecollectionsAPICreateRoleCollectionsRequest
*/
func (a *RolecollectionsAPIService) CreateRoleCollections(ctx context.Context) RolecollectionsAPICreateRoleCollectionsRequest {
	return RolecollectionsAPICreateRoleCollectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *RolecollectionsAPIService) CreateRoleCollectionsExecute(r RolecollectionsAPICreateRoleCollectionsRequest) (map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.CreateRoleCollections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleCollectionsBulkDto == nil {
		return localVarReturnValue, nil, reportError("roleCollectionsBulkDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleCollectionsBulkDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPICreateRoleCollectionsForUserRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollectionListDto *RoleCollectionListDto
}

func (r RolecollectionsAPICreateRoleCollectionsForUserRequest) RoleCollectionListDto(roleCollectionListDto RoleCollectionListDto) RolecollectionsAPICreateRoleCollectionsForUserRequest {
	r.roleCollectionListDto = &roleCollectionListDto
	return r
}

func (r RolecollectionsAPICreateRoleCollectionsForUserRequest) Execute() (*RoleCollectionListDto, *http.Response, error) {
	return r.ApiService.CreateRoleCollectionsForUserExecute(r)
}

/*
CreateRoleCollectionsForUser Create bulk role collections for a User

create role collections for a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RolecollectionsAPICreateRoleCollectionsForUserRequest
*/
func (a *RolecollectionsAPIService) CreateRoleCollectionsForUser(ctx context.Context) RolecollectionsAPICreateRoleCollectionsForUserRequest {
	return RolecollectionsAPICreateRoleCollectionsForUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoleCollectionListDto
func (a *RolecollectionsAPIService) CreateRoleCollectionsForUserExecute(r RolecollectionsAPICreateRoleCollectionsForUserRequest) (*RoleCollectionListDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoleCollectionListDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.CreateRoleCollectionsForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/users/current/rolecollections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleCollectionListDto == nil {
		return localVarReturnValue, nil, reportError("roleCollectionListDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleCollectionListDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RoleCollectionListDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RoleCollectionListDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v RoleCollectionListDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIDeleteRoleCollectionByNameRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollectionName string
}

func (r RolecollectionsAPIDeleteRoleCollectionByNameRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteRoleCollectionByNameExecute(r)
}

/*
DeleteRoleCollectionByName Deletes a role collection.

Deletes a role collection specified by the name of the role collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleCollectionName Name of collection to be retrieved
 @return RolecollectionsAPIDeleteRoleCollectionByNameRequest
*/
func (a *RolecollectionsAPIService) DeleteRoleCollectionByName(ctx context.Context, roleCollectionName string) RolecollectionsAPIDeleteRoleCollectionByNameRequest {
	return RolecollectionsAPIDeleteRoleCollectionByNameRequest{
		ApiService: a,
		ctx: ctx,
		roleCollectionName: roleCollectionName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RolecollectionsAPIService) DeleteRoleCollectionByNameExecute(r RolecollectionsAPIDeleteRoleCollectionByNameRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.DeleteRoleCollectionByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/{roleCollectionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"roleCollectionName"+"}", url.PathEscape(parameterValueToString(r.roleCollectionName, "roleCollectionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIDeleteRoleCollectionsRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollectionNamesDto *RoleCollectionNamesDto
}

func (r RolecollectionsAPIDeleteRoleCollectionsRequest) RoleCollectionNamesDto(roleCollectionNamesDto RoleCollectionNamesDto) RolecollectionsAPIDeleteRoleCollectionsRequest {
	r.roleCollectionNamesDto = &roleCollectionNamesDto
	return r
}

func (r RolecollectionsAPIDeleteRoleCollectionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRoleCollectionsExecute(r)
}

/*
DeleteRoleCollections Bulk delete of role collections.

Bulk delete of role collections specified by the name of the role collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RolecollectionsAPIDeleteRoleCollectionsRequest
*/
func (a *RolecollectionsAPIService) DeleteRoleCollections(ctx context.Context) RolecollectionsAPIDeleteRoleCollectionsRequest {
	return RolecollectionsAPIDeleteRoleCollectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RolecollectionsAPIService) DeleteRoleCollectionsExecute(r RolecollectionsAPIDeleteRoleCollectionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.DeleteRoleCollections")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleCollectionNamesDto == nil {
		return nil, reportError("roleCollectionNamesDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleCollectionNamesDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RolecollectionsAPIDeleteRoleCollectionsForUserRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollectionListDto *RoleCollectionListDto
}

func (r RolecollectionsAPIDeleteRoleCollectionsForUserRequest) RoleCollectionListDto(roleCollectionListDto RoleCollectionListDto) RolecollectionsAPIDeleteRoleCollectionsForUserRequest {
	r.roleCollectionListDto = &roleCollectionListDto
	return r
}

func (r RolecollectionsAPIDeleteRoleCollectionsForUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRoleCollectionsForUserExecute(r)
}

/*
DeleteRoleCollectionsForUser Delete bulk role collections of User

delete role collections for a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RolecollectionsAPIDeleteRoleCollectionsForUserRequest
*/
func (a *RolecollectionsAPIService) DeleteRoleCollectionsForUser(ctx context.Context) RolecollectionsAPIDeleteRoleCollectionsForUserRequest {
	return RolecollectionsAPIDeleteRoleCollectionsForUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RolecollectionsAPIService) DeleteRoleCollectionsForUserExecute(r RolecollectionsAPIDeleteRoleCollectionsForUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.DeleteRoleCollectionsForUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/users/current/rolecollections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleCollectionListDto == nil {
		return nil, reportError("roleCollectionListDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleCollectionListDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type RolecollectionsAPIDeleteRoleFromRoleCollectionRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollectionName string
	roleTemplateAppID string
	roleName string
	roleTemplateName string
}

func (r RolecollectionsAPIDeleteRoleFromRoleCollectionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteRoleFromRoleCollectionExecute(r)
}

/*
DeleteRoleFromRoleCollection Deletes a role from a role collection.

Deletes a role specified by the role reference from a role collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleCollectionName Name of the role collection
 @param roleTemplateAppID AppID of the Role Template
 @param roleName Name of the Role
 @param roleTemplateName Name of the Role Template
 @return RolecollectionsAPIDeleteRoleFromRoleCollectionRequest
*/
func (a *RolecollectionsAPIService) DeleteRoleFromRoleCollection(ctx context.Context, roleCollectionName string, roleTemplateAppID string, roleName string, roleTemplateName string) RolecollectionsAPIDeleteRoleFromRoleCollectionRequest {
	return RolecollectionsAPIDeleteRoleFromRoleCollectionRequest{
		ApiService: a,
		ctx: ctx,
		roleCollectionName: roleCollectionName,
		roleTemplateAppID: roleTemplateAppID,
		roleName: roleName,
		roleTemplateName: roleTemplateName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RolecollectionsAPIService) DeleteRoleFromRoleCollectionExecute(r RolecollectionsAPIDeleteRoleFromRoleCollectionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.DeleteRoleFromRoleCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/{roleCollectionName}/roles/{roleTemplateAppID}/{roleName}/{roleTemplateName}"
	localVarPath = strings.Replace(localVarPath, "{"+"roleCollectionName"+"}", url.PathEscape(parameterValueToString(r.roleCollectionName, "roleCollectionName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleTemplateAppID"+"}", url.PathEscape(parameterValueToString(r.roleTemplateAppID, "roleTemplateAppID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleName"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleTemplateName"+"}", url.PathEscape(parameterValueToString(r.roleTemplateName, "roleTemplateName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIDeleteRolesFromRoleCollectionRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollectionName string
	roleReference *[]RoleReference
}

func (r RolecollectionsAPIDeleteRolesFromRoleCollectionRequest) RoleReference(roleReference []RoleReference) RolecollectionsAPIDeleteRolesFromRoleCollectionRequest {
	r.roleReference = &roleReference
	return r
}

func (r RolecollectionsAPIDeleteRolesFromRoleCollectionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteRolesFromRoleCollectionExecute(r)
}

/*
DeleteRolesFromRoleCollection Remove roles from role collection.

Updates a role collection by removing an array of roles from role collection. Specify the roles by role name, application ID, and role template name. These roles are removed from the role collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleCollectionName Name of the role collection
 @return RolecollectionsAPIDeleteRolesFromRoleCollectionRequest
*/
func (a *RolecollectionsAPIService) DeleteRolesFromRoleCollection(ctx context.Context, roleCollectionName string) RolecollectionsAPIDeleteRolesFromRoleCollectionRequest {
	return RolecollectionsAPIDeleteRolesFromRoleCollectionRequest{
		ApiService: a,
		ctx: ctx,
		roleCollectionName: roleCollectionName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RolecollectionsAPIService) DeleteRolesFromRoleCollectionExecute(r RolecollectionsAPIDeleteRolesFromRoleCollectionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.DeleteRolesFromRoleCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/{roleCollectionName}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"roleCollectionName"+"}", url.PathEscape(parameterValueToString(r.roleCollectionName, "roleCollectionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.roleReference == nil {
		return localVarReturnValue, nil, reportError("roleReference is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.roleReference
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIGetRoleCollectionByNameRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollectionName string
	withRoles *bool
	withUsers *bool
	withGroups *bool
}

func (r RolecollectionsAPIGetRoleCollectionByNameRequest) WithRoles(withRoles bool) RolecollectionsAPIGetRoleCollectionByNameRequest {
	r.withRoles = &withRoles
	return r
}

func (r RolecollectionsAPIGetRoleCollectionByNameRequest) WithUsers(withUsers bool) RolecollectionsAPIGetRoleCollectionByNameRequest {
	r.withUsers = &withUsers
	return r
}

func (r RolecollectionsAPIGetRoleCollectionByNameRequest) WithGroups(withGroups bool) RolecollectionsAPIGetRoleCollectionByNameRequest {
	r.withGroups = &withGroups
	return r
}

func (r RolecollectionsAPIGetRoleCollectionByNameRequest) Execute() (*RoleCollection, *http.Response, error) {
	return r.ApiService.GetRoleCollectionByNameExecute(r)
}

/*
GetRoleCollectionByName Returns a role collection.

Returns information about a role collection identified by the name of the role collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleCollectionName Name of collection to be retrieved
 @return RolecollectionsAPIGetRoleCollectionByNameRequest
*/
func (a *RolecollectionsAPIService) GetRoleCollectionByName(ctx context.Context, roleCollectionName string) RolecollectionsAPIGetRoleCollectionByNameRequest {
	return RolecollectionsAPIGetRoleCollectionByNameRequest{
		ApiService: a,
		ctx: ctx,
		roleCollectionName: roleCollectionName,
	}
}

// Execute executes the request
//  @return RoleCollection
func (a *RolecollectionsAPIService) GetRoleCollectionByNameExecute(r RolecollectionsAPIGetRoleCollectionByNameRequest) (*RoleCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoleCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.GetRoleCollectionByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/{roleCollectionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"roleCollectionName"+"}", url.PathEscape(parameterValueToString(r.roleCollectionName, "roleCollectionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withRoles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withRoles", r.withRoles, "form", "")
	} else {
		var defaultValue bool = true
		r.withRoles = &defaultValue
	}
	if r.withUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withUsers", r.withUsers, "form", "")
	} else {
		var defaultValue bool = false
		r.withUsers = &defaultValue
	}
	if r.withGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "withGroups", r.withGroups, "form", "")
	} else {
		var defaultValue bool = false
		r.withGroups = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIGetRoleCollectionsRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	showRoles *bool
	showUsers *bool
	showGroups *bool
	skip *int32
	top *int32
	name *string
	readOnly *string
}

// Set this parameter to true, to include the roles, that are associated with the role collections.
func (r RolecollectionsAPIGetRoleCollectionsRequest) ShowRoles(showRoles bool) RolecollectionsAPIGetRoleCollectionsRequest {
	r.showRoles = &showRoles
	return r
}

// Set this parameter to true, to include the users, to whom the role collections are assigned.
func (r RolecollectionsAPIGetRoleCollectionsRequest) ShowUsers(showUsers bool) RolecollectionsAPIGetRoleCollectionsRequest {
	r.showUsers = &showUsers
	return r
}

// Set this parameter to true, to include the groups, to which the role collections are assigned.
func (r RolecollectionsAPIGetRoleCollectionsRequest) ShowGroups(showGroups bool) RolecollectionsAPIGetRoleCollectionsRequest {
	r.showGroups = &showGroups
	return r
}

// Set this parameter to enable paging starting at record &lt;skip&gt;.
func (r RolecollectionsAPIGetRoleCollectionsRequest) Skip(skip int32) RolecollectionsAPIGetRoleCollectionsRequest {
	r.skip = &skip
	return r
}

// Set this parameter to get at most &lt;top&gt; records. If set, maxed at 500.
func (r RolecollectionsAPIGetRoleCollectionsRequest) Top(top int32) RolecollectionsAPIGetRoleCollectionsRequest {
	r.top = &top
	return r
}

// Set this parameter to filter the result based on the name of the rolecollections.
func (r RolecollectionsAPIGetRoleCollectionsRequest) Name(name string) RolecollectionsAPIGetRoleCollectionsRequest {
	r.name = &name
	return r
}

// Set this parameter to filter the result based on the readOnly property of the rolecollections.
func (r RolecollectionsAPIGetRoleCollectionsRequest) ReadOnly(readOnly string) RolecollectionsAPIGetRoleCollectionsRequest {
	r.readOnly = &readOnly
	return r
}

func (r RolecollectionsAPIGetRoleCollectionsRequest) Execute() ([]RoleCollection, *http.Response, error) {
	return r.ApiService.GetRoleCollectionsExecute(r)
}

/*
GetRoleCollections Returns role collections.

Returns all role collections which exist within the current subaccount, sorted alphabetically by their names.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return RolecollectionsAPIGetRoleCollectionsRequest
*/
func (a *RolecollectionsAPIService) GetRoleCollections(ctx context.Context) RolecollectionsAPIGetRoleCollectionsRequest {
	return RolecollectionsAPIGetRoleCollectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RoleCollection
func (a *RolecollectionsAPIService) GetRoleCollectionsExecute(r RolecollectionsAPIGetRoleCollectionsRequest) ([]RoleCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.GetRoleCollections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showRoles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showRoles", r.showRoles, "form", "")
	}
	if r.showUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showUsers", r.showUsers, "form", "")
	}
	if r.showGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showGroups", r.showGroups, "form", "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "form", "")
	}
	if r.top != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "top", r.top, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.readOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "readOnly", r.readOnly, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	appId string
	roleTemplateName string
	roleName string
}

func (r RolecollectionsAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest) Execute() ([]RoleCollection, *http.Response, error) {
	return r.ApiService.GetRoleCollectionsByAppIdTemplateNameAndRoleNameExecute(r)
}

/*
GetRoleCollectionsByAppIdTemplateNameAndRoleName Get RoleCollections containing a role identified by appId, roleTemplateName and role name

Retrieve all RoleCollections containing a role. The role is identified by appId, roleTemplateName and role name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId Application ID
 @param roleTemplateName Name of the Role Template
 @param roleName Name of the Role
 @return RolecollectionsAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest
*/
func (a *RolecollectionsAPIService) GetRoleCollectionsByAppIdTemplateNameAndRoleName(ctx context.Context, appId string, roleTemplateName string, roleName string) RolecollectionsAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest {
	return RolecollectionsAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest{
		ApiService: a,
		ctx: ctx,
		appId: appId,
		roleTemplateName: roleTemplateName,
		roleName: roleName,
	}
}

// Execute executes the request
//  @return []RoleCollection
func (a *RolecollectionsAPIService) GetRoleCollectionsByAppIdTemplateNameAndRoleNameExecute(r RolecollectionsAPIGetRoleCollectionsByAppIdTemplateNameAndRoleNameRequest) ([]RoleCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.GetRoleCollectionsByAppIdTemplateNameAndRoleName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/roles/{appId}/{roleTemplateName}/{roleName}"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleTemplateName"+"}", url.PathEscape(parameterValueToString(r.roleTemplateName, "roleTemplateName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"roleName"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIGetRoleCollectionsByPagingRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	pageId int32
	showRoles *bool
	showUsers *bool
	showGroups *bool
}

// Set this parameter to true, to include the roles, that are associated with the role collections.
func (r RolecollectionsAPIGetRoleCollectionsByPagingRequest) ShowRoles(showRoles bool) RolecollectionsAPIGetRoleCollectionsByPagingRequest {
	r.showRoles = &showRoles
	return r
}

// Set this parameter to true, to include the users, to whom the role collections are assigned.
func (r RolecollectionsAPIGetRoleCollectionsByPagingRequest) ShowUsers(showUsers bool) RolecollectionsAPIGetRoleCollectionsByPagingRequest {
	r.showUsers = &showUsers
	return r
}

// Set this parameter to true, to include the groups, to which the role collections are assigned.
func (r RolecollectionsAPIGetRoleCollectionsByPagingRequest) ShowGroups(showGroups bool) RolecollectionsAPIGetRoleCollectionsByPagingRequest {
	r.showGroups = &showGroups
	return r
}

func (r RolecollectionsAPIGetRoleCollectionsByPagingRequest) Execute() ([]RoleCollection, *http.Response, error) {
	return r.ApiService.GetRoleCollectionsByPagingExecute(r)
}

/*
GetRoleCollectionsByPaging Returns a page of role collections.

Returns the specified page of role collection search result. The role collections are the result of a previous paged GET request for role collections of the current subaccount.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pageId Page Id
 @return RolecollectionsAPIGetRoleCollectionsByPagingRequest
*/
func (a *RolecollectionsAPIService) GetRoleCollectionsByPaging(ctx context.Context, pageId int32) RolecollectionsAPIGetRoleCollectionsByPagingRequest {
	return RolecollectionsAPIGetRoleCollectionsByPagingRequest{
		ApiService: a,
		ctx: ctx,
		pageId: pageId,
	}
}

// Execute executes the request
//  @return []RoleCollection
func (a *RolecollectionsAPIService) GetRoleCollectionsByPagingExecute(r RolecollectionsAPIGetRoleCollectionsByPagingRequest) ([]RoleCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.GetRoleCollectionsByPaging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/pages/{pageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pageId"+"}", url.PathEscape(parameterValueToString(r.pageId, "pageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showRoles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showRoles", r.showRoles, "form", "")
	}
	if r.showUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showUsers", r.showUsers, "form", "")
	}
	if r.showGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showGroups", r.showGroups, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIGetRoleCollectionsByPaging1Request struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	pageId int32
	showRoles *bool
	showUsers *bool
	showGroups *bool
}

// Set this parameter to true, to include the roles, that are associated with the role collections.
func (r RolecollectionsAPIGetRoleCollectionsByPaging1Request) ShowRoles(showRoles bool) RolecollectionsAPIGetRoleCollectionsByPaging1Request {
	r.showRoles = &showRoles
	return r
}

// Set this parameter to true, to include the users, to whom the role collections are assigned.
func (r RolecollectionsAPIGetRoleCollectionsByPaging1Request) ShowUsers(showUsers bool) RolecollectionsAPIGetRoleCollectionsByPaging1Request {
	r.showUsers = &showUsers
	return r
}

// Set this parameter to true, to include the groups, to which the role collections are assigned.
func (r RolecollectionsAPIGetRoleCollectionsByPaging1Request) ShowGroups(showGroups bool) RolecollectionsAPIGetRoleCollectionsByPaging1Request {
	r.showGroups = &showGroups
	return r
}

func (r RolecollectionsAPIGetRoleCollectionsByPaging1Request) Execute() ([]RoleCollection, *http.Response, error) {
	return r.ApiService.GetRoleCollectionsByPaging1Execute(r)
}

/*
GetRoleCollectionsByPaging1 Returns a page of role collections.

Returns the specified page of role collection search result. The role collections are the result of a previous paged GET request for role collections of the current subaccount.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pageId Page Id
 @return RolecollectionsAPIGetRoleCollectionsByPaging1Request
*/
func (a *RolecollectionsAPIService) GetRoleCollectionsByPaging1(ctx context.Context, pageId int32) RolecollectionsAPIGetRoleCollectionsByPaging1Request {
	return RolecollectionsAPIGetRoleCollectionsByPaging1Request{
		ApiService: a,
		ctx: ctx,
		pageId: pageId,
	}
}

// Execute executes the request
//  @return []RoleCollection
func (a *RolecollectionsAPIService) GetRoleCollectionsByPaging1Execute(r RolecollectionsAPIGetRoleCollectionsByPaging1Request) ([]RoleCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.GetRoleCollectionsByPaging1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/pages"
	localVarPath = strings.Replace(localVarPath, "{"+"pageId"+"}", url.PathEscape(parameterValueToString(r.pageId, "pageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showRoles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showRoles", r.showRoles, "form", "")
	}
	if r.showUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showUsers", r.showUsers, "form", "")
	}
	if r.showGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showGroups", r.showGroups, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIGetRoleCollectionsByPaging2Request struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	pageId int32
	showRoles *bool
	showUsers *bool
	showGroups *bool
}

// Set this parameter to true, to include the roles, that are associated with the role collections.
func (r RolecollectionsAPIGetRoleCollectionsByPaging2Request) ShowRoles(showRoles bool) RolecollectionsAPIGetRoleCollectionsByPaging2Request {
	r.showRoles = &showRoles
	return r
}

// Set this parameter to true, to include the users, to whom the role collections are assigned.
func (r RolecollectionsAPIGetRoleCollectionsByPaging2Request) ShowUsers(showUsers bool) RolecollectionsAPIGetRoleCollectionsByPaging2Request {
	r.showUsers = &showUsers
	return r
}

// Set this parameter to true, to include the groups, to which the role collections are assigned.
func (r RolecollectionsAPIGetRoleCollectionsByPaging2Request) ShowGroups(showGroups bool) RolecollectionsAPIGetRoleCollectionsByPaging2Request {
	r.showGroups = &showGroups
	return r
}

func (r RolecollectionsAPIGetRoleCollectionsByPaging2Request) Execute() ([]RoleCollection, *http.Response, error) {
	return r.ApiService.GetRoleCollectionsByPaging2Execute(r)
}

/*
GetRoleCollectionsByPaging2 Returns a page of role collections.

Returns the specified page of role collection search result. The role collections are the result of a previous paged GET request for role collections of the current subaccount.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pageId Page Id
 @return RolecollectionsAPIGetRoleCollectionsByPaging2Request
*/
func (a *RolecollectionsAPIService) GetRoleCollectionsByPaging2(ctx context.Context, pageId int32) RolecollectionsAPIGetRoleCollectionsByPaging2Request {
	return RolecollectionsAPIGetRoleCollectionsByPaging2Request{
		ApiService: a,
		ctx: ctx,
		pageId: pageId,
	}
}

// Execute executes the request
//  @return []RoleCollection
func (a *RolecollectionsAPIService) GetRoleCollectionsByPaging2Execute(r RolecollectionsAPIGetRoleCollectionsByPaging2Request) ([]RoleCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RoleCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.GetRoleCollectionsByPaging2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/pages/"
	localVarPath = strings.Replace(localVarPath, "{"+"pageId"+"}", url.PathEscape(parameterValueToString(r.pageId, "pageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showRoles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showRoles", r.showRoles, "form", "")
	}
	if r.showUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showUsers", r.showUsers, "form", "")
	}
	if r.showGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showGroups", r.showGroups, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []RoleCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIGetRoleCollectionsForUserRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	userId string
}

func (r RolecollectionsAPIGetRoleCollectionsForUserRequest) Execute() (*RoleCollectionListDto, *http.Response, error) {
	return r.ApiService.GetRoleCollectionsForUserExecute(r)
}

/*
GetRoleCollectionsForUser Get role collections of User

all role collections for a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId User ID
 @return RolecollectionsAPIGetRoleCollectionsForUserRequest
*/
func (a *RolecollectionsAPIService) GetRoleCollectionsForUser(ctx context.Context, userId string) RolecollectionsAPIGetRoleCollectionsForUserRequest {
	return RolecollectionsAPIGetRoleCollectionsForUserRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return RoleCollectionListDto
func (a *RolecollectionsAPIService) GetRoleCollectionsForUserExecute(r RolecollectionsAPIGetRoleCollectionsForUserRequest) (*RoleCollectionListDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoleCollectionListDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.GetRoleCollectionsForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/users/{userId}/rolecollections"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RoleCollectionListDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RoleCollectionListDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v RoleCollectionListDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIGetRoleCollectionsForUser1Request struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	userId string
}

func (r RolecollectionsAPIGetRoleCollectionsForUser1Request) Execute() (*RoleCollectionListDto, *http.Response, error) {
	return r.ApiService.GetRoleCollectionsForUser1Execute(r)
}

/*
GetRoleCollectionsForUser1 Get role collections of User

all role collections for a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId User ID
 @return RolecollectionsAPIGetRoleCollectionsForUser1Request
*/
func (a *RolecollectionsAPIService) GetRoleCollectionsForUser1(ctx context.Context, userId string) RolecollectionsAPIGetRoleCollectionsForUser1Request {
	return RolecollectionsAPIGetRoleCollectionsForUser1Request{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return RoleCollectionListDto
func (a *RolecollectionsAPIService) GetRoleCollectionsForUser1Execute(r RolecollectionsAPIGetRoleCollectionsForUser1Request) (*RoleCollectionListDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoleCollectionListDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.GetRoleCollectionsForUser1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/users/current/rolecollections"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v RoleCollectionListDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RoleCollectionListDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v RoleCollectionListDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type RolecollectionsAPIGetRolesByRoleCollectionNameRequest struct {
	ctx context.Context
	ApiService RolecollectionsAPI
	roleCollectionName string
}

func (r RolecollectionsAPIGetRolesByRoleCollectionNameRequest) Execute() ([]Role, *http.Response, error) {
	return r.ApiService.GetRolesByRoleCollectionNameExecute(r)
}

/*
GetRolesByRoleCollectionName Returns the roles of a role collection.

Returns information about the roles of a role collection specified by the name of the role collection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param roleCollectionName Name of the role collection
 @return RolecollectionsAPIGetRolesByRoleCollectionNameRequest
*/
func (a *RolecollectionsAPIService) GetRolesByRoleCollectionName(ctx context.Context, roleCollectionName string) RolecollectionsAPIGetRolesByRoleCollectionNameRequest {
	return RolecollectionsAPIGetRolesByRoleCollectionNameRequest{
		ApiService: a,
		ctx: ctx,
		roleCollectionName: roleCollectionName,
	}
}

// Execute executes the request
//  @return []Role
func (a *RolecollectionsAPIService) GetRolesByRoleCollectionNameExecute(r RolecollectionsAPIGetRolesByRoleCollectionNameRequest) ([]Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RolecollectionsAPIService.GetRolesByRoleCollectionName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sap/rest/authorization/v2/rolecollections/{roleCollectionName}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"roleCollectionName"+"}", url.PathEscape(parameterValueToString(r.roleCollectionName, "roleCollectionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []Role
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []Role
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []Role
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
