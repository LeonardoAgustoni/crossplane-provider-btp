/*
Entitlements Service

The Entitlements service provides REST APIs that manage the assignments of entitlements and quotas to subaccounts and directories.   Entitlements and their quota are automatically assigned to the global account when a customer order is fulfilled. Use the APIs in this service to manage the distribution of this global quota to your directories and subaccounts.   NOTE: These APIs are relevant only for cloud management tools feature set B. For details and information about whether this applies to your global account, see [Cloud Management Tools - Feature Set Overview](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/Cloud/en-US/caf4e4e23aef4666ad8f125af393dfb2.html).  See also: * [Authorization](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/3670474a58c24ac2b082e76cbbd9dc19.html) * [Rate Limiting](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/77b217b3f57a45b987eb7fbc3305ce1e.html) * [Error Response Format](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/77fef2fb104b4b1795e2e6cee790e8b8.html) * [Asynchronous Jobs](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/0a0a6ab0ad114d72a6611c1c6b21683e.html)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ManageAssignedEntitlementsAPIService ManageAssignedEntitlementsAPI service
type ManageAssignedEntitlementsAPIService service

type ApiCreateOrUpdateEntitlementsRequest struct {
	ctx context.Context
	ApiService *ManageAssignedEntitlementsAPIService
	directoryGUID string
	directoryAssignmentsRequestPayloadCollection *DirectoryAssignmentsRequestPayloadCollection
}

func (r ApiCreateOrUpdateEntitlementsRequest) DirectoryAssignmentsRequestPayloadCollection(directoryAssignmentsRequestPayloadCollection DirectoryAssignmentsRequestPayloadCollection) ApiCreateOrUpdateEntitlementsRequest {
	r.directoryAssignmentsRequestPayloadCollection = &directoryAssignmentsRequestPayloadCollection
	return r
}

func (r ApiCreateOrUpdateEntitlementsRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.CreateOrUpdateEntitlementsExecute(r)
}

/*
CreateOrUpdateEntitlements Assign or update an entitlement in a directory

Assign or update an entitlement plan of a service, multitenant application, or environment, to a directory. This is valid only for directories that are enabled to manage their entitlements.The amount that can be assigned to plans that are based on a numeric quota, is subject to available quota in the global account.Note that some environments, such as Cloud Foundry, are available by default to all subaccounts, and therefore are not displayed as entitlements.<br/><br/>Required scopes: $XSAPPNAME.directory.entitlement.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The unique ID of the directory to which the entitlement is assigned.
 @return ApiCreateOrUpdateEntitlementsRequest
*/
func (a *ManageAssignedEntitlementsAPIService) CreateOrUpdateEntitlements(ctx context.Context, directoryGUID string) ApiCreateOrUpdateEntitlementsRequest {
	return ApiCreateOrUpdateEntitlementsRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return string
func (a *ManageAssignedEntitlementsAPIService) CreateOrUpdateEntitlementsExecute(r ApiCreateOrUpdateEntitlementsRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageAssignedEntitlementsAPIService.CreateOrUpdateEntitlements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/directories/{directoryGUID}/assignments"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.directoryAssignmentsRequestPayloadCollection == nil {
		return localVarReturnValue, nil, reportError("directoryAssignmentsRequestPayloadCollection is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.directoryAssignmentsRequestPayloadCollection
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDirectoryAssignmentsRequest struct {
	ctx context.Context
	ApiService *ManageAssignedEntitlementsAPIService
	directoryGUID *string
	subaccountGUID *string
	includeAutoManagedPlans *bool
	acceptLanguage *string
	entitledServicesOnly *bool
	assignedServiceName *string
}

// The ID of the directory for which to show the entitlements and quota assignments.
func (r ApiGetDirectoryAssignmentsRequest) DirectoryGUID(directoryGUID string) ApiGetDirectoryAssignmentsRequest {
	r.directoryGUID = &directoryGUID
	return r
}

// The ID of the subaccount for which to show the entitlements and quota assignments.
func (r ApiGetDirectoryAssignmentsRequest) SubaccountGUID(subaccountGUID string) ApiGetDirectoryAssignmentsRequest {
	r.subaccountGUID = &subaccountGUID
	return r
}

// Specify if to include also services that are automatically entitled to a global account when the global account is created. Default is false.
func (r ApiGetDirectoryAssignmentsRequest) IncludeAutoManagedPlans(includeAutoManagedPlans bool) ApiGetDirectoryAssignmentsRequest {
	r.includeAutoManagedPlans = &includeAutoManagedPlans
	return r
}

// Indicates the natural language and locale that the client prefers.
func (r ApiGetDirectoryAssignmentsRequest) AcceptLanguage(acceptLanguage string) ApiGetDirectoryAssignmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// When true: (1) only the available services for which the global account is entitled (under &#39;entitledServices&#39;) are retrieved, and (2) services that are assigned to directories and subaccounts in the global account are not retrieved (under &#39;assignedServices&#39;). When false, both &#39;entitledServices&#39; and &#39;assignedServices&#39; are retrieved. Default value: false
func (r ApiGetDirectoryAssignmentsRequest) EntitledServicesOnly(entitledServicesOnly bool) ApiGetDirectoryAssignmentsRequest {
	r.entitledServicesOnly = &entitledServicesOnly
	return r
}

// A specific service for which to return subaccount quota assignments in the global account or directory. If not specified, then all services in the global account or directory are returned.
func (r ApiGetDirectoryAssignmentsRequest) AssignedServiceName(assignedServiceName string) ApiGetDirectoryAssignmentsRequest {
	r.assignedServiceName = &assignedServiceName
	return r
}

func (r ApiGetDirectoryAssignmentsRequest) Execute() (*EntitledAndAssignedServicesResponseObject, *http.Response, error) {
	return r.ApiService.GetDirectoryAssignmentsExecute(r)
}

/*
GetDirectoryAssignments Get all the entitlements and quota assignments

Get all the entitlements and quota assignments for a global account and its directories and subaccounts. The information returned depends on the target of this API:
- When the target is a global account, you view all the resources a global account and its directories and subaccounts are entitled to use. In this case, you omit the directoryGUID and subaccountGUID in the API call.
- When the target is directory (applies only to directories that can manage their own entitlements), you view all the resources the directory and its subaccounts are entitled to use.
- When the target is a specific subaccount, you can view all the entitlements and quota assigned to the subaccount.<br/><br/>Required scopes: $XSAPPNAME.directory.entitlement.read or $XSAPPNAME.global-account.entitlement.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDirectoryAssignmentsRequest
*/
func (a *ManageAssignedEntitlementsAPIService) GetDirectoryAssignments(ctx context.Context) ApiGetDirectoryAssignmentsRequest {
	return ApiGetDirectoryAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EntitledAndAssignedServicesResponseObject
func (a *ManageAssignedEntitlementsAPIService) GetDirectoryAssignmentsExecute(r ApiGetDirectoryAssignmentsRequest) (*EntitledAndAssignedServicesResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntitledAndAssignedServicesResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageAssignedEntitlementsAPIService.GetDirectoryAssignments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/assignments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.directoryGUID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryGUID", r.directoryGUID, "form", "")
	}
	if r.subaccountGUID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subaccountGUID", r.subaccountGUID, "form", "")
	}
	if r.includeAutoManagedPlans != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAutoManagedPlans", r.includeAutoManagedPlans, "form", "")
	} else {
		var defaultValue bool = false
		r.includeAutoManagedPlans = &defaultValue
	}
	if r.entitledServicesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entitledServicesOnly", r.entitledServicesOnly, "form", "")
	}
	if r.assignedServiceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignedServiceName", r.assignedServiceName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGlobalAccountAssignmentsRequest struct {
	ctx context.Context
	ApiService *ManageAssignedEntitlementsAPIService
	subaccountGUID *string
	acceptLanguage *string
	includeAutoManagedPlans *bool
	entitledServicesOnly *bool
	assignedServiceName *string
}

// Use the parameter to specify for which subaccount to view assigned entitlements. If left empty, the API returns the entitlements for the global account and all its subaccounts.
func (r ApiGetGlobalAccountAssignmentsRequest) SubaccountGUID(subaccountGUID string) ApiGetGlobalAccountAssignmentsRequest {
	r.subaccountGUID = &subaccountGUID
	return r
}

// Indicates the natural language and locale that the client prefers.
func (r ApiGetGlobalAccountAssignmentsRequest) AcceptLanguage(acceptLanguage string) ApiGetGlobalAccountAssignmentsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

// Specify if to include also services that are automatically assigned to a subaccount when the subaccount is created. Default is false.
func (r ApiGetGlobalAccountAssignmentsRequest) IncludeAutoManagedPlans(includeAutoManagedPlans bool) ApiGetGlobalAccountAssignmentsRequest {
	r.includeAutoManagedPlans = &includeAutoManagedPlans
	return r
}

// When true: (1) only the available services for which the global account is entitled (under &#39;entitledServices&#39;) are retrieved, and (2) services that are assigned to directories and subaccounts in the global account are not retrieved (under &#39;assignedServices&#39;). When false, both &#39;entitledServices&#39; and &#39;assignedServices&#39; are retrieved. Default value: false
func (r ApiGetGlobalAccountAssignmentsRequest) EntitledServicesOnly(entitledServicesOnly bool) ApiGetGlobalAccountAssignmentsRequest {
	r.entitledServicesOnly = &entitledServicesOnly
	return r
}

// A specific service for which to return subaccount quota assignments in the global account. If not specified, then all services in the global account are returned.
func (r ApiGetGlobalAccountAssignmentsRequest) AssignedServiceName(assignedServiceName string) ApiGetGlobalAccountAssignmentsRequest {
	r.assignedServiceName = &assignedServiceName
	return r
}

func (r ApiGetGlobalAccountAssignmentsRequest) Execute() (*EntitledAndAssignedServicesResponseObject, *http.Response, error) {
	return r.ApiService.GetGlobalAccountAssignmentsExecute(r)
}

/*
GetGlobalAccountAssignments Get entitlements assigned to a global account

Get details about all the entitlements assigned to a global account.<br/><br/>Required scopes: $XSAPPNAME.global-account.entitlement.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGlobalAccountAssignmentsRequest
*/
func (a *ManageAssignedEntitlementsAPIService) GetGlobalAccountAssignments(ctx context.Context) ApiGetGlobalAccountAssignmentsRequest {
	return ApiGetGlobalAccountAssignmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EntitledAndAssignedServicesResponseObject
func (a *ManageAssignedEntitlementsAPIService) GetGlobalAccountAssignmentsExecute(r ApiGetGlobalAccountAssignmentsRequest) (*EntitledAndAssignedServicesResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntitledAndAssignedServicesResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageAssignedEntitlementsAPIService.GetGlobalAccountAssignments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/globalAccountAssignments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.subaccountGUID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subaccountGUID", r.subaccountGUID, "form", "")
	}
	if r.includeAutoManagedPlans != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAutoManagedPlans", r.includeAutoManagedPlans, "form", "")
	} else {
		var defaultValue bool = false
		r.includeAutoManagedPlans = &defaultValue
	}
	if r.entitledServicesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entitledServicesOnly", r.entitledServicesOnly, "form", "")
	}
	if r.assignedServiceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignedServiceName", r.assignedServiceName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetServicePlansRequest struct {
	ctx context.Context
	ApiService *ManageAssignedEntitlementsAPIService
	subaccountServicePlansRequestPayloadCollection *SubaccountServicePlansRequestPayloadCollection
}

func (r ApiSetServicePlansRequest) SubaccountServicePlansRequestPayloadCollection(subaccountServicePlansRequestPayloadCollection SubaccountServicePlansRequestPayloadCollection) ApiSetServicePlansRequest {
	r.subaccountServicePlansRequestPayloadCollection = &subaccountServicePlansRequestPayloadCollection
	return r
}

func (r ApiSetServicePlansRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SetServicePlansExecute(r)
}

/*
SetServicePlans Assign entitlements to subaccounts

Assign or update an entitlement of a service, multitenant application, or environment plan, to a subaccount. Subaccounts can be located either directly under the global account, or under a directory in the global account.When a subaccount is located directly under the global account, total amount of service or application plan it is entitled to consume cannot exceed the entitlement’s quota for the global account. This is also true for the directories that are not enabled to manage their quota as they consume the quota from the global account.<br/>For the directories that are enabled to manage their entitlements, the total amounts assigned to subaccounts cannot exceed the entitlement’s quota for these directories.<br/>Note that some environments, such as Cloud Foundry, are available by default to all subaccounts, and therefore are not displayed as entitlements.<br/><br/>Required scopes: $XSAPPNAME.global-account.entitlement.subaccount.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetServicePlansRequest
*/
func (a *ManageAssignedEntitlementsAPIService) SetServicePlans(ctx context.Context) ApiSetServicePlansRequest {
	return ApiSetServicePlansRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *ManageAssignedEntitlementsAPIService) SetServicePlansExecute(r ApiSetServicePlansRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageAssignedEntitlementsAPIService.SetServicePlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/subaccountServicePlans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subaccountServicePlansRequestPayloadCollection == nil {
		return localVarReturnValue, nil, reportError("subaccountServicePlansRequestPayloadCollection is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subaccountServicePlansRequestPayloadCollection
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEntitlementsRequest struct {
	ctx context.Context
	ApiService *ManageAssignedEntitlementsAPIService
	directoryGUID string
	directoryAssignmentsPatchUpdateRequestPayloadCollection *DirectoryAssignmentsPatchUpdateRequestPayloadCollection
}

func (r ApiUpdateEntitlementsRequest) DirectoryAssignmentsPatchUpdateRequestPayloadCollection(directoryAssignmentsPatchUpdateRequestPayloadCollection DirectoryAssignmentsPatchUpdateRequestPayloadCollection) ApiUpdateEntitlementsRequest {
	r.directoryAssignmentsPatchUpdateRequestPayloadCollection = &directoryAssignmentsPatchUpdateRequestPayloadCollection
	return r
}

func (r ApiUpdateEntitlementsRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.UpdateEntitlementsExecute(r)
}

/*
UpdateEntitlements Update an existing entitlement in a directory

Update an entitlement plan of a service, multitenant application, or environment that is already assigned to a directory. Use it to apply changes to the distribution of a plan and quota to subaccounts in a directory. You cannot use this API to assign new plans or to change the quota assigned to a directory. This API is valid only for directories that are enabled to manage their entitlements. Note that some environments, such as Cloud Foundry, are available by default to all subaccounts, and therefore are not displayed as entitlements.<br/><br/>Required scopes: $XSAPPNAME.directory.entitlement.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param directoryGUID The unique ID of the directory to which the entitlement is assigned.
 @return ApiUpdateEntitlementsRequest
*/
func (a *ManageAssignedEntitlementsAPIService) UpdateEntitlements(ctx context.Context, directoryGUID string) ApiUpdateEntitlementsRequest {
	return ApiUpdateEntitlementsRequest{
		ApiService: a,
		ctx: ctx,
		directoryGUID: directoryGUID,
	}
}

// Execute executes the request
//  @return string
func (a *ManageAssignedEntitlementsAPIService) UpdateEntitlementsExecute(r ApiUpdateEntitlementsRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageAssignedEntitlementsAPIService.UpdateEntitlements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/directories/{directoryGUID}/assignments"
	localVarPath = strings.Replace(localVarPath, "{"+"directoryGUID"+"}", url.PathEscape(parameterValueToString(r.directoryGUID, "directoryGUID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.directoryAssignmentsPatchUpdateRequestPayloadCollection == nil {
		return localVarReturnValue, nil, reportError("directoryAssignmentsPatchUpdateRequestPayloadCollection is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.directoryAssignmentsPatchUpdateRequestPayloadCollection
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiExceptionResponseObject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
